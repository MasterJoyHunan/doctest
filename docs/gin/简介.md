### 当前版本 1.6.3

### `Gin`  框架介绍
 `Gin`  是一个 go 写的 web 框架，具有高性能的优点

官方地址：[https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)
### 目录结构
```
│  .gitignore
│  .travis.yml
│  auth.go
│  AUTHORS.md
│  auth_test.go
│  BENCHMARKS.md
│  benchmarks_test.go
│  CHANGELOG.md
│  codecov.yml
│  CODE_OF_CONDUCT.md
│  context.go
│  context_appengine.go
│  context_test.go
│  CONTRIBUTING.md
│  debug.go
│  debug_test.go
│  deprecated.go
│  deprecated_test.go
│  doc.go
│  errors.go
│  errors_test.go
│  fs.go
│  gin.go
│  gin_integration_test.go
│  gin_test.go
│  githubapi_test.go
│  go.mod
│  go.sum
│  LICENSE
│  logger.go
│  logger_test.go
│  Makefile
│  middleware_test.go
│  mode.go
│  mode_test.go
│  path.go
│  path_test.go
│  README.md
│  recovery.go
│  recovery_test.go
│  response_writer.go
│  response_writer_test.go
│  routergroup.go
│  routergroup_test.go
│  routes_test.go
│  test_helpers.go
│  tree.go
│  tree_test.go
│  utils.go
│  utils_test.go
│  version.go
│
├─.github
│      ISSUE_TEMPLATE.md
│      PULL_REQUEST_TEMPLATE.md
│
├─binding
│      binding.go
│      binding_msgpack_test.go
│      binding_nomsgpack.go
│      binding_test.go
│      default_validator.go
│      form.go
│      form_mapping.go
│      form_mapping_benchmark_test.go
│      form_mapping_test.go
│      header.go
│      json.go
│      json_test.go
│      msgpack.go
│      msgpack_test.go
│      multipart_form_mapping.go
│      multipart_form_mapping_test.go
│      protobuf.go
│      query.go
│      uri.go
│      validate_test.go
│      xml.go
│      xml_test.go
│      yaml.go
│      yaml_test.go
│
├─examples
│      README.md
│
├─ginS
│      gins.go
│      README.md
│
├─internal
│  ├─bytesconv
│  │      bytesconv.go
│  │      bytesconv_test.go
│  │
│  └─json
│          json.go
│          jsoniter.go
│
├─render
│      data.go
│      html.go
│      json.go
│      msgpack.go
│      protobuf.go
│      reader.go
│      reader_test.go
│      redirect.go
│      render.go
│      render_msgpack_test.go
│      render_test.go
│      text.go
│      xml.go
│      yaml.go
│
└─testdata
    ├─certificate
    │      cert.pem
    │      key.pem
    │
    ├─protoexample
    │      test.pb.go
    │      test.proto
    │
    └─template
            hello.tmpl
            raw.tmpl
```

整个  `Gin`  结构也就这么点文件，说明  `Gin`  是个轻量级，快速的框架是不无道理的
接下来我们去除无用的代码（test代码，example代码），重点研究  `Gin`  的精髓，去除之后仅剩下
```go
│  auth.go              // 权限中间件，可无视
│  context.go           // 核心
│  context_appengine.go // 编译使用，debug 同样可无视
│  debug.go             // 打印输出，可无视
│  deprecated.go        // debug使用，可无视
│  doc.go               // doc 文档 无内容，可无视
│  errors.go            // 错误处理
│  fs.go                // 文件的工具类，没几行代码
│  gin.go               // 核心
│  logger.go            // 日志中间件，可无视
│  mode.go              // 设置开发模式 debug | release | test 同样可无视
│  path.go              // 对应 url 路径的 工具类
│  recovery.go          // recovery中间件，可无视
│  response_writer.go   // 核心，
│  routergroup.go       // 核心，路由抽象
│  tree.go              // 核心，前缀树
│  utils.go             // 工具类
│  version.go           // 版本，可无视
│
├─binding               // 参数绑定以及验证
│      binding.go
│      binding_nomsgpack.go
│      default_validator.go
│      form.go
│      form_mapping.go
│      header.go
│      json.go
│      msgpack.go
│      multipart_form_mapping.go
│      protobuf.go
│      query.go
│      uri.go
│      xml.go
│      yaml.go
│
├─ginS                // 实验功能
│      gins.go
│
├─internal 
│  ├─bytesconv 
│  │      bytesconv.go // 字符串与 byte 互转工具
│  │
│  └─json             // json解析器
│          json.go
│          jsoniter.go
│
└─render              // 渲染
    data.go
    html.go
    json.go 
    msgpack.go
    protobuf.go
    reader.go
    redirect.go
    render.go
    text.go
    xml.go
    yaml.go
```

接下来我们从入口文件分析 `Gin` 到底做了什么，一个最简单的使用方式如下：

```go
package main

import "github.com/gin-gonic/gin"

func main() {
	r := gin.New()
	r.GET("/index", func(context *gin.Context) {
		context.JSON(200, gin.H{
			"code": 1,
			"data": "hello world",
		})
	})
	panic(r.Run(":8080"))
}

```

#### `gin.New()` 做了什么
见名思意，New 肯定是创建了一个对象，看源码，让我们看看 `Gin` 到底创建了一个什么对象让我们使用

顺带说一下，源码中出现了 `var _ IRouter = &Engine{}` 这样的代码，看上去很难理解，其实这代码是用来类型推断的，其作用是，在编译时，判断 `Engine` 类型是否实现 `IRouter` 接口

```go
func New() *Engine {
	......
	engine := &Engine{ // 实例化 gin 的引擎
		RouterGroup: RouterGroup{ // 路由
			Handlers: nil,
			basePath: "/",
			root:     true,
		},
		FuncMap:                template.FuncMap{},
		RedirectTrailingSlash:  true,
		RedirectFixedPath:      false,
		HandleMethodNotAllowed: false,
		ForwardedByClientIP:    true,
		AppEngine:              defaultAppEngine,
		UseRawPath:             false,
		UnescapePathValues:     true,
		MaxMultipartMemory:     defaultMultipartMemory,
		trees:                  make(methodTrees, 0, 9), // 路由--前缀树
		delims:                 render.Delims{Left: "{{", Right: "}}"},
		secureJsonPrefix:       "while(1);",
	}
	engine.RouterGroup.engine = engine
	engine.pool.New = func() interface{} {
		return engine.allocateContext()
	}
	return engine
}

```
#### RouterGroup 是个啥？
看定义
```go
type RouterGroup struct {
	Handlers HandlersChain // 对对应路径处理的方法链
	basePath string // 路由地址 如果是 a/b/c 这里指存放 a/b/c
	engine   *Engine 
	root     bool // 是否是根目录
}
```
不难判断，其实这玩意就是一个对路由分组处理的对象

其核心方法
```go
func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {
	absolutePath := group.calculateAbsolutePath(relativePath) // 获取绝对路径 -- example relativePath=/a/:base group.basePath=/q/e then absolutePath = /q/e/a/:base
	handlers = group.combineHandlers(handlers) // 将新的handlers合并到方法链最后
	group.engine.addRoute(httpMethod, absolutePath, handlers) // 路由核心方法
	return group.returnObj() // 返回自己
}
```


再来看看 `addRoute` 做了什么
```go
func (engine *Engine) addRoute(method, path string, handlers HandlersChain) {
	assert1(path[0] == '/', "path must begin with '/'")
	assert1(method != "", "HTTP method can not be empty")
	assert1(len(handlers) > 0, "there must be at least one handler")

	debugPrintRoute(method, path, handlers)
	root := engine.trees.get(method) // 判断
	if root == nil {
		root = new(node)
		root.fullPath = "/"
		engine.trees = append(engine.trees, methodTree{method: method, root: root})
	}
	root.addRoute(path, handlers)
}
```