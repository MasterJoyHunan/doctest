### 在前缀树中查找对应的handle
感慨：前缀树的查找相对于前缀树的插入容易多了

干巴巴的看代码，没有代入感，所有接下来我以 `/index/index/foo/bar/coo` 其对应的路由是 `/index/index/:foo/bar/:one/`

**TSR 表示 trailing slash redirect ，尾部斜杆重定向**

```go
// 返回对象，可能是不想返回一大串东西，所以用一个结构体封装了吧
type nodeValue struct {
	handlers HandlersChain // 保存 Handlers 数组，如果找到了对应的节点的话
	params   Params 	   // 保存 uri 请求的参数
	tsr      bool          // 尾部斜杆重定向
	fullPath string        // 返回对应的路由路径 如 /index/:foo/bar/:one/ 
}
```
```go
func (n *node) getValue(path string, po Params, unescape bool) (value nodeValue) {
	// 没搞懂这里，在我看来，所有调用 getValue() 方法的地方 po 都是为 nil
	value.params = po
walk:
	for {
		prefix := n.path

		// 找到了对应的路由
		if path == prefix {

			// 判断该节点是否有对应的 handlers，有则返回
			if value.handlers = n.handlers; value.handlers != nil {
				value.fullPath = n.fullPath
				return
			}
			// 以下都是 handlers == nil 情况

			// 如果最后一级是 '/' 并且当前找到的节点下面有动态路由，并且当前找到的节点不是根节点，尝试"尾部斜杆重定向"
			// 这里考虑的应该是这种情况 foo/ => foo/:bar
			if path == "/" && n.wildChild && n.nType != root {
				value.tsr = true
				return
			}

			// 这里考虑的这种情况 foo => foo/bar
			// len(n.path) == 1 && n.handlers != nil 是考虑这种情况 foo => foo/
			// n.nType == catchAll && n.children[0].handlers != nil 是考虑这种情况 foo => foo/*any
			indices := n.indices
			for i, max := 0, len(indices); i < max; i++ {
				if indices[i] == '/' {
					n = n.children[i]
					value.tsr = (len(n.path) == 1 && n.handlers != nil) ||
						(n.nType == catchAll && n.children[0].handlers != nil)
					return
				}
			}
			return
		}

		// 未找到的情况
		if len(path) > len(prefix) && path[:len(prefix)] == prefix {
			path = path[len(prefix):]

			// 如果当前节点无通配符子节点，则查该节点的子节点
			if !n.wildChild {
				c := path[0]
				indices := n.indices
				for i, max := 0, len(indices); i < max; i++ {
					if c == indices[i] {
						n = n.children[i]
						continue walk
					}
				}

				// 如果没有找到该节点对应的子节点，且最后的路径为 '/'，
				// 且当前节点是有处理函数的。则尝试"尾部斜杆重定向"
				value.tsr = path == "/" && n.handlers != nil
				return
			}

			// 该节点下有通配符节点的情况，直接将子节点设为当前节点，因为有通配符节点必定只有一个子节点
			n = n.children[0]
			switch n.nType {
			case param:

				// 查找到最后一个 / 结束的地方
				end := 0
				for end < len(path) && path[end] != '/' {
					end++
				}

				// 将参数和值存入 value
				if cap(value.params) < int(n.maxParams) {
					value.params = make(Params, 0, n.maxParams)
				}

				// 看不懂这里，直接 append 不行吗？
				i := len(value.params)
				value.params = value.params[:i+1]
				value.params[i].Key = n.path[1:]
				val := path[:end]
				if unescape {
					var err error
					if value.params[i].Value, err = url.QueryUnescape(val); err != nil {
						value.params[i].Value = val // fallback, in case of error
					}
				} else {
					value.params[i].Value = val
				}

				// 说明还没到底，需要再查找下级
				if end < len(path) {
					if len(n.children) > 0 {
						path = path[end:]
						n = n.children[0]
						continue walk
					}

					// 没找到对应的下级的情况
					value.tsr = len(path) == end+1
					return
				}

				// 到底了，判断有没有对应的处理函数
				if value.handlers = n.handlers; value.handlers != nil {
					value.fullPath = n.fullPath
					return
				}

				// 没有对应的函数，判断下级是不是 '/'，且有对应的处理函数，则尝试"尾部斜杆重定向"
				if len(n.children) == 1 {
					n = n.children[0]
					value.tsr = n.path == "/" && n.handlers != nil
				}
				return

			case catchAll: // 没什么好说的
				if cap(value.params) < int(n.maxParams) {
					value.params = make(Params, 0, n.maxParams)
				}
				i := len(value.params)
				value.params = value.params[:i+1]
				value.params[i].Key = n.path[2:]
				if unescape {
					var err error
					if value.params[i].Value, err = url.QueryUnescape(path); err != nil {
						value.params[i].Value = path
					}
				} else {
					value.params[i].Value = path
				}

				value.handlers = n.handlers
				value.fullPath = n.fullPath
				return

			default:
				panic("invalid node type")
			}
		}

		// len(path) < len(prefix) || path[:len(prefix)] != prefix 的情况
		// 判断是否属于以下两种情况，然后尝试"尾部斜杆重定向"
		// 1. path == "/"
		// 2. 下面全部需要符合，应该是考虑这种情况 'foo' => 'foo/'
		//		2.1 len(prefix) == len(path)+1
		//      2.2 prefix[len(path)] == '/'
		//      2.3 path == prefix[:len(prefix)-1]
		//      2.4 n.handlers != nil
		value.tsr = (path == "/") ||
			(len(prefix) == len(path)+1 &&
				prefix[len(path)] == '/' &&
				path == prefix[:len(prefix)-1] &&
				n.handlers != nil)
		return
	}
}
```