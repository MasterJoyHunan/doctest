### `gin` 的错误处理
```go
type Context struct {
	...
	Errors     errorMsgs   // 错误
	...
}
```
框架将一次处理请求所有的错误都都在保存在这。如果有需要的话，我们可以调用对应的方法，对错误进行处理，首先看看 `errorMsgs` 的结构。我猜就是一个数组结构
```go
type errorMsgs []*Error

type Error struct {
	Err  error       // 错误详情
	Type ErrorType   // 错误类型
	Meta interface{} // 错误元数据
}

// 具体错误类型
type ErrorType uint64

ErrorTypeBind ErrorType = 1 << 63         // 参数绑定错误，最常用的之一
ErrorTypeRender ErrorType = 1 << 62		  // Context.Render() 错误
ErrorTypePrivate ErrorType = 1 << 0       // private error
ErrorTypePublic ErrorType = 1 << 1        // public error 最常用的之一
ErrorTypeAny ErrorType = 1<<64 - 1        // any other error
ErrorTypeNu = 2                           // any other error
```

看看 `errorMsgs` 结构体有什么方法
```go
// 查询某个 type 的所有错误
func (a errorMsgs) ByType(typ ErrorType) errorMsgs 
// 查询最后加入的错误
func (a errorMsgs) Last() *Error 
// []string 方式返回所有错误描述
func (a errorMsgs) Errors() []string 
// map 方式返回所有错误
func (a errorMsgs) JSON() interface{} 
// []byte 方式返回所有错误
func (a errorMsgs) MarshalJSON() ([]byte, error) 
// string 方式返回所有错误
func (a errorMsgs) String() string 
```
看看 `Error` 结构体有什么方法
```go
// 将一个错误设置 type 标签
func (msg *Error) SetType(flags ErrorType) *Error 
// 将一个错误设置元数据
func (msg *Error) SetMeta(data interface{}) *Error 
// map 方式返回错误
func (msg *Error) JSON() interface{} 
// []byte 方式返回错误
func (msg *Error) MarshalJSON() ([]byte, error) 
// 返回错误描述
func (msg Error) Error() string 
// 判断一个错误是否是 type 类型
func (msg *Error) IsType(flags ErrorType) bool 
```
总的来说，错误处理没什么太多好说的，一看就懂。

### 使用方式

#### 设置错误
```go
func ArticleCateAdd(c *gin.Context) {
	var ac request.ArticleCateAdd
	if err := c.ShouldBindJSON(&ac); err != nil {
		c.Error(err).SetType(gin.ErrorTypeBind)
		return
	}
	if err := service.ArticleCateAdd(ac); err != nil {
		c.Error(err).SetType(gin.ErrorTypePublic)
		return
	}
	c.JSON(200, gin.H{
		"code":1,
		"msg": "添加成功"
	})
}
```
#### 对错误进行处理
```go
// 错误处理
func ErrorHandle() gin.HandlerFunc {
	return func(c *gin.Context) {

		c.Next()
		if len(c.Errors) == 0  {
			return
		}

		// 参数验证错误
		if err := c.Errors.ByType(gin.ErrorTypeBind).Last(); err != nil {

			// 自定义错误提示
			baseErrorMessage := validate.ErrorTitleMessage
			if coverMessage, ok := err.Meta.(map[string]string); ok {
				for k, v := range coverMessage {
					baseErrorMessage[k] = v
				}
			}

			if validateErrs, ok := err.Err.(validator.ValidationErrors); ok {
				for _, e := range validateErrs {
					zhErrorMessage := e.Translate(validate.Trans)
					// 替换错误提示
					if res, ok := baseErrorMessage[e.Field()]; ok {
						zhErrorMessage = strings.Replace(zhErrorMessage, e.Field(), res, 1)
					}
					c.AbortWithStatusJSON(200, gin.H{
						"code": 0,
						"data": "",
						"msg":  zhErrorMessage,
					})
					return
				}
			}
			if unmarshalErrs, ok := err.Err.(*json.UnmarshalTypeError); ok {
				// 替换错误提示
				errField := unmarshalErrs.Field
				if res, ok := baseErrorMessage[errField]; ok {
					errField = res
				}
				c.AbortWithStatusJSON(200, gin.H{
					"code": 0,
					"data": "",
					"msg":  "参数[ " + errField + " ]对应的值非法",
				})
				logger.Logger.Error("传参解析异常", unmarshalErrs.Error())
				return
			}
		}

		// 其他异常
		if err := c.Errors.ByType(gin.ErrorTypePublic).Last(); err != nil {
			if normalValidateErrs, ok := err.Err.(*myerr.NormalValidateError); ok {
				// 普通验证错误
				c.AbortWithStatusJSON(200, gin.H{
					"code": 0,
					"data": "",
					"msg":  normalValidateErrs.Error(),
				})
				return
			} else if dbValidateErrs, ok := err.Err.(*myerr.DbValidateError); ok {
				// 数据库验证错误
				c.AbortWithStatusJSON(200, gin.H{
					"code": 0,
					"data": "",
					"msg":  dbValidateErrs.Error(),
				})
				return
			} else if gorm.IsRecordNotFoundError(err.Err) {
				// 数据未找到
				c.AbortWithStatusJSON(200, gin.H{
					"code": 0,
					"data": "",
					"msg":  "数据不存在",
				})
				return
			}
		}

		// 其他未知错误
		c.AbortWithStatusJSON(500, gin.H{
			"code": 500,
			"data": "",
			"msg":  "系统错误",
		})
		logger.Logger.Error(c.Errors.Last().Error())
	}
}
```