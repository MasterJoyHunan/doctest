### gin 参数的获取

### Query 参数
根据官方文档推荐的获取 `Query` 参数的方法，我们来看看 `gin` 做了什么
```go
index.GET("/index", func(context *gin.Context) {
	a1 := context.Query("a1")
	a2 := context.DefaultQuery("a2", "1")
	context.JSON(200, gin.H{
		"code": 1,
		"data": []string{a1, a2},
	})
})
```
```go
// alias GetQuery
func (c *Context) Query(key string) string {
	value, _ := c.GetQuery(key)
	return value
}
```
```go
// 实际调用的是 GetQueryArray 实现方法的复用
func (c *Context) GetQuery(key string) (string, bool) {
	if values, ok := c.GetQueryArray(key); ok {
		return values[0], ok
	}
	return "", false
}
```
```go
func (c *Context) GetQueryArray(key string) ([]string, bool) {
	c.getQueryCache()
	if values, ok := c.queryCache[key]; ok && len(values) > 0 {
		return values, true
	}
	return []string{}, false
}
```
```go
// 如果需要多次获取 Query ，就先将 Query 结果缓存起来
func (c *Context) getQueryCache() {
	if c.queryCache == nil {
		c.queryCache = c.Request.URL.Query()
	}
}
```
可以看到，这里其实就是对 `http 库的一个封装`，调用的也是 `Request` 对象的获取 `Query` 的方法

再来看看 `DefaultQuery` 实际上也是同样的调用 `GetQuery`
```go
func (c *Context) DefaultQuery(key, defaultValue string) string {
	if value, ok := c.GetQuery(key); ok {
		return value
	}
	return defaultValue
}
```

### Param 参数
推荐使用 `context.Param()` 获取 path 上的参数
```go
index.GET("/index/:foo", func(context *gin.Context) {
	f1 := context.Param("foo")
	f2 := context.Param("bar")
	p := context.Params

	context.JSON(200, gin.H{
		"code": 1,
		"data": []interface{} {f1, f2, p},
	})
})
// {"code":1,"data":["aoe","",[{"Key":"foo","Value":"aoe"}]]}
```
一步一步深入
```go
func (c *Context) Param(key string) string {
	return c.Params.ByName(key)
}
```
看看 `Params` 的结构
```go
type Params []Param

type Param struct {
	Key   string
	Value string
}
```
```go
func (ps Params) ByName(name string) (va string) {
	va, _ = ps.Get(name)
	return
}
```
```go
func (ps Params) Get(name string) (string, bool) {
	for _, entry := range ps {
		if entry.Key == name {
			return entry.Value, true
		}
	}
	return "", false
}
```
这里的代码很简单，不需要多解释了，关键是 `Params` 是什么时候被赋值上去的呢？-- 参考《`gin` 处理请求》一节

### FormData 参数
推荐使用 `context.PostForm()` 获取 post 的参数
```go
index.POST("/index", func(c *gin.Context) {
	d1 := c.PostForm("foo")
	d2 := c.DefaultPostForm("bar", "def")
	c.JSON(200, gin.H{
		"code": "1",
		"data": []interface{}{d1, d2},
	})
})
```
```go
func (c *Context) PostForm(key string) string {
	value, _ := c.GetPostForm(key)
	return value
}
```
```go
func (c *Context) GetPostForm(key string) (string, bool) {
	if values, ok := c.GetPostFormArray(key); ok {
		return values[0], ok
	}
	return "", false
}
```
```go
func (c *Context) GetPostFormArray(key string) ([]string, bool) {
	c.getFormCache()
	if values := c.formCache[key]; len(values) > 0 {
		return values, true
	}
	return []string{}, false
}
```
```go
func (c *Context) getFormCache() {
	if c.formCache == nil {
		c.formCache = make(url.Values)
		req := c.Request
		// 调用 http 的 ParseMultipartForm 方法
		if err := req.ParseMultipartForm(c.engine.MaxMultipartMemory); err != nil {
			if err != http.ErrNotMultipart {
				debugPrint("error on parse multipart form array: %v", err)
			}
		}
		c.formCache = req.PostForm
	}
}
```
和获取 `query` 参数一致，这里不做解释了

### Json 参数并绑定到结构体， **推荐**
这种是最常用的获取参数的方式，也是需要重点介绍的一种，先看看最简单的用法
```go
type Req struct {
	Foo string
	Bar string
}
index.POST("/index", func(c *gin.Context) {
	var req Req
	c.BindJSON(&req)
	c.JSON(200, gin.H{
		"code": "1",
		"data": req,
	})
})
```
这种方式会将参数绑定到结构体中，使其代码更加简洁。

追溯源码
```go
func (c *Context) BindJSON(obj interface{}) error {
	return c.MustBindWith(obj, binding.JSON) // 关注第二个参数
}
```
```go
func (c *Context) MustBindWith(obj interface{}, b binding.Binding) error {
	if err := c.ShouldBindWith(obj, b); err != nil {
		c.AbortWithError(http.StatusBadRequest, err).SetType(ErrorTypeBind) // nolint: errcheck
		return err
	}
	return nil
}
```
```go
func (c *Context) ShouldBindWith(obj interface{}, b binding.Binding) error {
	// 其实就是 binding.JSON.Bind(c.Request, obj)，这里为了扩展需要，需要传实现了 binding.Binding 接口的参数
	return b.Bind(c.Request, obj) 
}
```
```go
//  binding.go
var ( 
	JSON          = jsonBinding{} // 关注这个
	XML           = xmlBinding{}
	Form          = formBinding{}
	Query         = queryBinding{}
	FormPost      = formPostBinding{}
	FormMultipart = formMultipartBinding{}
	ProtoBuf      = protobufBinding{}
	MsgPack       = msgpackBinding{}
	YAML          = yamlBinding{}
	Uri           = uriBinding{}
	Header        = headerBinding{}
)
```
```go
// binding/json.go

type jsonBinding struct{}

func (jsonBinding) Name() string {
	return "json"
}

func (jsonBinding) Bind(req *http.Request, obj interface{}) error {
	if req == nil || req.Body == nil {
		return fmt.Errorf("invalid request")
	}
	return decodeJSON(req.Body, obj)
}

func (jsonBinding) BindBody(body []byte, obj interface{}) error {
	return decodeJSON(bytes.NewReader(body), obj)
}

// 核心方法
// 需要注意一下，json.NewDecoder(r) 中的 json 和编译有关，
// 参考 《Go语言中自动选择json解析库》 https://www.flysnow.org/2017/11/05/go-auto-choice-json-libs.html
// 类似于适配器模式
func decodeJSON(r io.Reader, obj interface{}) error {
	decoder := json.NewDecoder(r)
	......
	if err := decoder.Decode(obj); err != nil {
		return err
	}
	// 解析到对应的结构体之后需要进行验证，参考下面 --参数的校验
	return validate(obj)
}
```

如果出现错误则，将返回 400，且不再执行其他中间件
```go
func (c *Context) AbortWithError(code int, err error) *Error {
	c.AbortWithStatus(code)
	return c.Error(err)
}
```
### 参数的校验--只支持结构体方式
关于参数的校验，`gin` 没有自己实现，而是使用了开源的库 `github.com/go-playground/validator/v10` **注：不同 `gin` 版本可能会依赖不同的 `validator` 版本**

```go
type defaultValidator struct {
    // 这里很有意思，用了 sync.Once 来保证某个方法只会调用一次，这里指 初始化方法 lazyinit()
    // 类似于单例模式
	once     sync.Once 
    
    // import "github.com/go-playground/validator/v10"
	validate *validator.Validate 
}

// defaultValidator 必须实现 StructValidator 接口
var _ StructValidator = &defaultValidator{}

// Validator 是具有 StructValidator 接口的
var Validator StructValidator = &defaultValidator{}

// StructValidator 接口
type StructValidator interface {
	ValidateStruct(interface{}) error
	Engine() interface{}
}

func validate(obj interface{}) error {
	if Validator == nil {
		return nil
	}
	return Validator.ValidateStruct(obj)
}
```
```go
func (v *defaultValidator) lazyinit() {
	v.once.Do(func() {
		v.validate = validator.New()
		v.validate.SetTagName("binding")
	})
}
```
从这里看到 `validate` 设置了 `tag` = `binding`, 才会校验，所以我们需要这样做
```go
type LoginUser struct {
	Username   string `binding:"required,max=255" example:"admin"`                 // 用户名
	Password   string `binding:"required,max=255" example:"admin"`                 // 密码
	VerifyCode string `json:"verify_code" binding:"required,len=4" example:"9527"` // 验证码
}
```
```go
func (v *defaultValidator) ValidateStruct(obj interface{}) error {
	value := reflect.ValueOf(obj)
	valueType := value.Kind()
	if valueType == reflect.Ptr {
		valueType = value.Elem().Kind()
	}
	if valueType == reflect.Struct {
		v.lazyinit()
		if err := v.validate.Struct(obj); err != nil {
			return err
		}
	}
	return nil
}
```
这里调用了 `validate.Struct(obj)` 的方法，有兴趣的可以看看 `validate` 的源码，这里讲的是 `gin` 所以不再深入

看这两种方式绑定和校验，按自己的需求选择其中一种
```go
// 常用，如果校验失败，会 abort ，且返回 400 错误码。其实就是对 ShouldBindJSON() + AbortWithError() 的封装
func BindJSON(obj interface{}) error

// 个人常用，不会 abort ,需要自己处理逻辑，相对更灵活
func ShouldBindJSON(obj interface{}) error 

// 绑定粒度更细的有
// 只绑定Get
func ShouldBindQuery()

// 绑定uri
func ShouldBindUri()
```
### 附--常用 `validate` 校验规则
参考：

* [结构字段验证－－validator.v9](https://www.cnblogs.com/zhzhlong/p/10033234.html)