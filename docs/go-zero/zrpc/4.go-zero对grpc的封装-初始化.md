#### grpc 的日志初始化

```go
func init() {
	InitLogger()
}

func InitLogger() {
	once.Do(func() {
		grpclog.SetLoggerV2(new(Logger)) 
	})
}

type Logger struct{}

func (l *Logger) Error(args ...interface{}) {
	logx.Error(args...)
}

func (l *Logger) Errorf(format string, args ...interface{}) {
	logx.Errorf(format, args...)
}
......
```

日志没什么好说的，只要实现了对应了接口即可，将日志对象写入即可

#### grpc 的服务发现

```go
func init() {
	resolver.Register()
}
func Register() {
	internal.RegisterResolver()
}
func RegisterResolver() {
	resolver.Register(&directResolverBuilder)
	resolver.Register(&discovResolverBuilder)
	resolver.Register(&etcdResolverBuilder)
	resolver.Register(&k8sResolverBuilder)
}
```

服务发现主要用于 grpc 的客户端，用于调用其他的 rpc 服务

首先需要看构建客户端的时候，如果不是使用  NewClientWithTarget（）来构建的，则会调用 BuildTarget（）方法

```go
func (cc RpcClientConf) BuildTarget() (string, error) {
	if len(cc.Endpoints) > 0 {
        // 构建直连 target -- 如传入 []string{"192.168.0.111:8181","192.168.0.112:8181"
        // 构建的target = direct:///192.168.0.111:8181,192.168.0.112:8181
		return resolver.BuildDirectTarget(cc.Endpoints), nil
	} else if len(cc.Target) > 0 {
        // 构建自定义 target -- 如 k8s://some-app-grpc:8081
		return cc.Target, nil
	}
	......
    // 构建服务发现 target -- Hosts=[]string{"localhost:123", "localhost:456"} key="foo"
    // 返回 discov://localhost:123,localhost:456/foo
	return resolver.BuildDiscovTarget(cc.Etcd.Hosts, cc.Etcd.Key), nil
}
```

在建立连接时候会将 target 作为参数传入

```go
func (c *client) dial(server string, opts ...ClientOption) error {
   ......
   // server 参数就是上面生成的 target 
   conn, err := grpc.DialContext(timeCtx, server, options...)
   ......
   return nil
}
```

##### direct  直连服务解析

```go
func (d *directBuilder) Build(target resolver.Target, cc resolver.ClientConn, _ resolver.BuildOptions) (
   resolver.Resolver, error) {
   var addrs []resolver.Address
    // 将 direct:///192.168.0.111:8181,192.168.0.112:8181 转换为 []string{"192.168.0.111:8181","192.168.0.112:8181"}
   endpoints := strings.FieldsFunc(targets.GetEndpoints(target), func(r rune) bool {
      return r == EndpointSepChar
   })
	
   // 对 endpoints 进行重新洗牌
   for _, val := range subset(endpoints, subsetSize) {
      addrs = append(addrs, resolver.Address{
         Addr: val,
      })
   }
   
   // 重点关注cc.UpdateState ()，将 ip+port 更新到 resolver.ClientConn
   // 这样就可以直接找到服务了
   if err := cc.UpdateState(resolver.State{
      Addresses: addrs,
   }); err != nil {
      return nil, err
   }

   return &nopResolver{cc: cc}, nil
}
```

##### discov  基于服务发现的服务解析

```go
func (b *discovBuilder) Build(target resolver.Target, cc resolver.ClientConn, _ resolver.BuildOptions) (
   resolver.Resolver, error) {
    // 将 discov://localhost:123,localhost:456/foo 转换为 []string{"localhost:123","localhost:456"}
   hosts := strings.FieldsFunc(targets.GetAuthority(target), func(r rune) bool {
      return r == EndpointSepChar
   })
    
   // 连接 etcd 服务，监听 foo 这个资源对象
   sub, err := discov.NewSubscriber(hosts, targets.GetEndpoints(target))
   if err != nil {
      return nil, err
   }

   update := func() {
      var addrs []resolver.Address
      for _, val := range subset(sub.Values(), subsetSize) {
         addrs = append(addrs, resolver.Address{
            Addr: val,
         })
      }
       // 和上面一样，更新 ip+port, 如果 etcd 有任何变动，这里也会跟着变
      if err := cc.UpdateState(resolver.State{
         Addresses: addrs,
      }); err != nil {
         logx.Error(err)
      }
   }
   sub.AddListener(update)
   update()

   return &nopResolver{cc: cc}, nil
}
```

##### k8s 服务解析 

个人认为 k8s 的 service 不需要解析吧，因为直接访问 service + 端口就可以直接连接服务。如果某个服务离线，service 会自动删除离线的服务的 endpoints

```
k8s:///my-svc:8080
k8s://ns1/my-svc:8080
```

#### grpc 的负载均衡

同上，个人觉得负载均衡留给 k8s 做就好了，或者留给 istio 处理

```go
func init() {
	balancer.Register(newBuilder())
}	
```

