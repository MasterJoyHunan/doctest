### 使用 goctl 生成 grpc 服务

```bash
goctl rpc protoc myrpc.proto --go_out=. --go-grpc_out=. --zrpc_out=.
```

生成目录如下

```
├─etc -- 配置 yaml 文件
├─internal -- 逻辑编写的目录
│  ├─config
│  ├─logic
│  ├─server
│  └─svc
├─myrpc -- goctl 生成
└─proto -- protoc 生成不用管
    └─myrpc
```

查看 goctl 生成的文件

```go
package myrpc

import (
	"context"

	"gz-example/myrpc/proto/myrpc" // goctl 生成

	"github.com/zeromicro/go-zero/zrpc"
	"google.golang.org/grpc"
)

type (
	Request  = myrpc.Request //指向 proto/myrpc
	Response = myrpc.Response //指向 proto/myrpc

	Myrpc interface {
		Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	}

	defaultMyrpc struct {
		cli zrpc.Client
	}
)

// 对 proto/myrpc 的封装
func NewMyrpc(cli zrpc.Client) Myrpc {
	return &defaultMyrpc{
		cli: cli,
	}
}

func (m *defaultMyrpc) Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	client := myrpc.NewMyrpcClient(m.cli.Conn())
	return client.Ping(ctx, in, opts...)
}
```

#### 测试用例

```go
func main() {
	//zrpc.MustNewClient(
	//	zrpc.NewDirectClientConf()) // 手动创建 grpc 客户端 -- 直连
	//zrpc.MustNewClient(
	//	zrpc.NewEtcdClientConf()) // 手动创建 grpc 客户端 -- etcd 方式
	//zrpc.NewClient() // 使用配置文件创建 grpc 客户端，自动判断是直连还是 etcd 方式
	client, _ := zrpc.NewClientWithTarget("127.0.0.1:8082") // 最朴素的方式 ip+port
	myrpcClient := myrpc.NewMyrpc(client)
	ping, _ := myrpcClient.Ping(context.Background(), &myrpc.Request{Ping: "1"})
	fmt.Println(ping.Pong)
}
```

NewClientWithTarget

```go
func NewClientWithTarget(target string, opts ...ClientOption) (Client, error) {
    // 1. 封装调用
	return internal.NewClient(target, opts...)
}
func NewClient(target string, opts ...ClientOption) (Client, error) {
	var cli client

	svcCfg := fmt.Sprintf(`{"loadBalancingPolicy":"%s"}`, p2c.Name)
    // 2. 添加负载均衡配置
	balancerOpt := WithDialOption(grpc.WithDefaultServiceConfig(svcCfg))
	opts = append([]ClientOption{balancerOpt}, opts...)
    
    // 3. 创建连接
	if err := cli.dial(target, opts...); err != nil {
		return nil, err
	}

	return &cli, nil
}
func (c *client) dial(server string, opts ...ClientOption) error {
    // 3.1 连接配置
	options := c.buildDialOptions(opts...)
	timeCtx, cancel := context.WithTimeout(context.Background(), dialTimeout)
	defer cancel()
    
    // 3.2 使用 grpc 进行连接
	conn, err := grpc.DialContext(timeCtx, server, options...)
	if err != nil {
		service := server
		if errors.Is(err, context.DeadlineExceeded) {
			pos := strings.LastIndexByte(server, separator)
			// len(server) - 1 is the index of last char
			if 0 < pos && pos < len(server)-1 {
				service = server[pos+1:]
			}
		}
		return fmt.Errorf("rpc dial: %s, error: %s, make sure rpc service %q is already started",
			server, err.Error(), service)
	}

	c.conn = conn
	return nil
}

func (c *client) buildDialOptions(opts ...ClientOption) []grpc.DialOption {
	var cliOpts ClientOptions
	for _, opt := range opts {
		opt(&cliOpts)
	}

	var options []grpc.DialOption
    // 判断是否使用 tls 连接，一般不需要
	if !cliOpts.Secure {
		options = append([]grpc.DialOption(nil), grpc.WithTransportCredentials(insecure.NewCredentials()))
	}

    // 判断是否阻塞连接，如果不设置，grpc 建立连接时，不会判断连接是否成功，会直接返回
	if !cliOpts.NonBlock {
		options = append(options, grpc.WithBlock())
	}

    // 添加各种拦截器，链路追踪，监控，断路器，超时
	options = append(options,
		WithUnaryClientInterceptors(
			clientinterceptors.UnaryTracingInterceptor,
			clientinterceptors.DurationInterceptor,
			clientinterceptors.PrometheusInterceptor,
			clientinterceptors.BreakerInterceptor,
			clientinterceptors.TimeoutInterceptor(cliOpts.Timeout),
		),
		WithStreamClientInterceptors(
			clientinterceptors.StreamTracingInterceptor,
		),
	)

	return append(options, cliOpts.DialOptions...)
}
```

myrpc.NewMyrpc(client)

```go
func NewMyrpc(cli zrpc.Client) Myrpc {
	return &defaultMyrpc{
		cli: cli,
	}
}

func (m *defaultMyrpc) Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
    // 每次调用方法的时候，复用连接，调用 grpc 
	client := myrpc.NewMyrpcClient(m.cli.Conn())
	return client.Ping(ctx, in, opts...)
}
```

init

```go
func init() {
	resolver.Register()
}
func Register() {
	internal.RegisterResolver()
}
func RegisterResolver() {
	resolver.Register(&directResolverBuilder)
	resolver.Register(&discovResolverBuilder)
	resolver.Register(&etcdResolverBuilder)
	resolver.Register(&k8sResolverBuilder)
}
```





整体帮我们做的就是

1. 根据配置文件创建连接对象
2. 添加负载均衡配置
3. 添加各种拦截器
4. 建立连接
5. 调用 grpc 的 New****Client 方法
6. 调用方法/接口
