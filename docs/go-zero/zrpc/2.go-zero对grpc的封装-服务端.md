### 使用 goctl 生成 grpc 服务

```bash
goctl rpc protoc myrpc.proto --go_out=. --go-grpc_out=. --zrpc_out=.
```

生成目录如下

```
├─etc -- 配置 yaml 文件
├─internal -- 逻辑编写的目录
│  ├─config
│  ├─logic
│  ├─server
│  └─svc
├─myrpc -- goctl 生成
└─proto -- protoc 生成不用管
    └─myrpc
```

查看main 文件

```go
func main() {
	flag.Parse()

	var c config.Config
	conf.MustLoad(*configFile, &c)
	ctx := svc.NewServiceContext(c) // 初始化服务上下文 -- 不重要
	svr := server.NewMyrpcServer(ctx) // 初始化服务 -- 该服务就是提供给 grpc 的服务，实现了 myrpc 定义的接口

    // 1.重点
	s := zrpc.MustNewServer(c.RpcServerConf, func(grpcServer *grpc.Server) {
		myrpc.RegisterMyrpcServer(grpcServer, svr)

		if c.Mode == service.DevMode || c.Mode == service.TestMode {
			reflection.Register(grpcServer)
		}
	})
	defer s.Stop()

	fmt.Printf("Starting rpc server at %s...\n", c.ListenOn)
    // 6. 建立监听
	s.Start()
}
```

```go
// MustNewServer returns a RpcSever, exits on any error.
func MustNewServer(c RpcServerConf, register internal.RegisterFn) *RpcServer {
    // 2. 调用 NewServer
	server, err := NewServer(c, register)
	.......
}

// NewServer returns a RpcServer.
func NewServer(c RpcServerConf, register internal.RegisterFn) (*RpcServer, error) {
	......
	if c.HasEtcd() {
		server, err = internal.NewRpcPubServer(c.Etcd, c.ListenOn, serverOptions...)
		if err != nil {
			return nil, err
		}
	} else {
        // 3.调用 internal.NewRpcServer -- 设置一些属性而已
		server = internal.NewRpcServer(c.ListenOn, serverOptions...)
	}

	server.SetName(c.Name)
    // 4.设置一些拦截器 (熔断，超时，权限)
	if err = setupInterceptors(server, c, metrics); err != nil {
		return nil, err
	}

	rpcServer := &RpcServer{
		server:   server,
		register: register,
	}
    // 5.日志初始化，prometheus初始化，zipkin 链路追踪初始化
	if err = c.SetUp(); err != nil {
		return nil, err
	}

	return rpcServer, nil
}
```

查看 s.Start() 调用的方法

```go
func (rs *RpcServer) Start() {
    // 1.调用 Start
	if err := rs.server.Start(rs.register); err != nil {
		logx.Error(err)
		panic(err)
	}
}
```

```go
func (s *rpcServer) Start(register RegisterFn) error {
	lis, err := net.Listen("tcp", s.address)
	if err != nil {
		return err
	}

	unaryInterceptors := []grpc.UnaryServerInterceptor{
		serverinterceptors.UnaryTracingInterceptor,
		serverinterceptors.UnaryCrashInterceptor,
		serverinterceptors.UnaryStatInterceptor(s.metrics),
		serverinterceptors.UnaryPrometheusInterceptor,
		serverinterceptors.UnaryBreakerInterceptor,
	}
	unaryInterceptors = append(unaryInterceptors, s.unaryInterceptors...)
	streamInterceptors := []grpc.StreamServerInterceptor{
		serverinterceptors.StreamTracingInterceptor,
		serverinterceptors.StreamCrashInterceptor,
		serverinterceptors.StreamBreakerInterceptor,
	}
	streamInterceptors = append(streamInterceptors, s.streamInterceptors...)
	options := append(s.options, WithUnaryServerInterceptors(unaryInterceptors...),
		WithStreamServerInterceptors(streamInterceptors...))
    
    // 2. 调用 grpc.NewServer() 方法，并传入各种简单拦截器和流拦截器
	server := grpc.NewServer(options...)
    
    // 3. 执行 main 方法传过来的方法参数
	register(server)
    //func(grpcServer *grpc.Server) {
	//	myrpc.RegisterMyrpcServer(grpcServer, svr)
	//
	//	if c.Mode == service.DevMode || c.Mode == service.TestMode {
	//		reflection.Register(grpcServer)
	//	}
	//})
    
    // 
	waitForCalled := proc.AddWrapUpListener(func() {
		server.GracefulStop()
	})
	defer waitForCalled()

	return server.Serve(lis)
}
```

proc.AddWrapUpListener 的作用

```go
waitForCalled := proc.AddWrapUpListener(func() {
    server.GracefulStop()
})
defer waitForCalled()
return server.Serve(lis)
//	约等于下面代码的作用
// ch := make(chan os.Signal, 1)
// signal.Notify(ch, os.Interrupt, os.Kill, syscall.SIGTERM)
// go func() {
//    <-ch
//    server.GracefulStop()
// }()
// return server.Serve(lis)
```

整体帮我们做的就是

1. 解析配置文件
2. 初始化服务上下文
3. 初始化服务
4. 初始化熔断，超时，限流器
5. 初始化日志，链路追踪，普罗米修斯监控
6. 初始化 grpc 服务
7. 设置 grpc 服务的拦截器 （熔断，超时，限流器，日志，链路追踪，普罗米修斯）
8. 设置优雅关闭
9. 运行 grpc 服务

