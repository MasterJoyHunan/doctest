#### grpcurl 的使用

前提是在服务端使用了 reflection.Register() 对当前 RPC 服务注册了

```go
func Setup() *grpc.Server {
	rpcServer := grpc.NewServer()
	message.RegisterMessageServer(rpcServer, &MessageServer{})
	listen, err := net.Listen("tcp", fmt.Sprintf("%s:%d", config.GrpcServerConf.Host, config.GrpcServerConf.Port))
	if err != nil {
		panic(err)
	}
	go func() {
		fmt.Println("grpc listen to ", listen.Addr().String())
		reflection.Register(rpcServer) // 关键代码
		rpcServer.Serve(listen)
	}()
	return rpcServer
}
```

默认情况下 grpcurl 使用 tls 连接, 但是我们在开发的时候,并没有设置 tls 连接,所以在使用的时候,需要设置连接模式

`grpcurl -plaintext`

##### 常用功能

查看提供的服务

```sh
grpcurl -plaintext 127.0.0.1:9999 list
# 返回
grpc.reflection.v1alpha.ServerReflection #固定会返回
message.Message # 你定义的接口
```

查看服务提供的功能

```sh
grpcurl -plaintext 127.0.0.1:9999 list message.Message
# 返回
message.Message.GrpcPaymentMessage # 服务中的方法
message.Message.GrpcRechargeMessage # 服务中的方法
```

查看方法详情

````sh
grpcurl -plaintext 127.0.0.1:9999 describe message.Message.GrpcRechargeMessage
# 返回
rpc GrpcRechargeMessage ( .message.RechargeMessageRequest ) returns ( .message.Empty ); # 括号里面的详情使用下面的方式查看
````

查看方法参数详情

```sh
grpcurl -plaintext 127.0.0.1:9999 describe .message.RechargeMessageRequest
# 返回 
message.RechargeMessageRequest is a message:
message RechargeMessageRequest {
  string userPhone = 1;
  string channel = 2;
  string type = 3;
  string amount = 4;
  string balance = 5;
  string remark = 6;
}
```

调用方法

```shell
grpcurl -plaintext -d '{"userPhone":"13054174174","channel":"14081", "type":"xxx3", "amount":"xxx4", "balance": "xxx5","remark":"xxx6"}' 127.0.0.1:9999 message.Message/GrpcRechargeMessage
```

