### go-zero 中的限流

####  `periodlimit` 单位时间限制访问次数

`periodlimit` 采用滑动窗口的算法，计算某段时间内的 QPS 到达一定的数量，则将服务降级

先简单看看基础用法

```go
const (
    seconds = 1
    total   = 100
    quota   = 5
)
// New limiter
l := NewPeriodLimit(seconds, quota, redis.NewRedis(s.Addr(), redis.NodeType), "periodlimit")

// take source
code, err := l.Take("first")
if err != nil {
    logx.Error(err)
    return true
}

// switch val => process request
switch code {
    case limit.OverQuota:
        logx.Errorf("OverQuota key: %v", key)
        return false
    case limit.Allowed:
        logx.Infof("AllowedQuota key: %v", key)
        return true
    case limit.HitQuota:
        logx.Errorf("HitQuota key: %v", key)
        // todo: maybe we need to let users know they hit the quota
        return false
    default:
        logx.Errorf("DefaultQuota key: %v", key)
        // unknown response, we just let the sms go
        return true
}
```

直接研究源码吧，从 `NewPeriodLimit` 开始

```go
// 初始化一个滑动窗口限流器
func NewPeriodLimit(period, quota int, limitStore *redis.Redis, keyPrefix string, opts ...LimitOption) *PeriodLimit {
   limiter := &PeriodLimit{
      period:     period,
      quota:      quota,
      limitStore: limitStore,
      keyPrefix:  keyPrefix,
   }

   for _, opt := range opts {
      opt(limiter)
   }

   return limiter
}
```
再看看 `PeriodLimit` 是个何方圣神

```go
type PeriodLimit struct {
   period     int // 时间窗口周期
   quota      int // 配额
   limitStore *redis.Redis // redis客户端
   keyPrefix  string // 对哪个资源
   align      bool // 周期判断
}
```

参数 `LimitOption` 是什么

```go
type LimitOption func(l *PeriodLimit)

// 设置时间窗口如何计算周期
func Align() LimitOption {
	return func(l *PeriodLimit) {
		l.align = true
	}
}
```

接下来看看关键方法

```go
func (h *PeriodLimit) Take(key string) (int, error) {
   // 使用 redis 的 lua 脚本干了一些什么事，看看脚本是什么
   resp, err := h.limitStore.Eval(periodScript, []string{h.keyPrefix + key}, []string{
      // 设置时间周期内的配额
      strconv.Itoa(h.quota),
      // 设置时间周期
      strconv.Itoa(h.calcExpireSeconds()),
   })
   if err != nil {
      return Unknown, err
   }

   code, ok := resp.(int64)
   if !ok {
      return Unknown, ErrUnknownCode
   }

   switch code {
   case internalOverQuota:
      // 超过配额了
      return OverQuota, nil
   case internalAllowed:
      // 未超过配额
      return Allowed, nil
   case internalHitQuota:
      // 配额到达临界点
      return HitQuota, nil
   default:
      // 未知错误
      return Unknown, ErrUnknownCode
   }
}
```
lua 脚本
```lua
local limit = tonumber(ARGV[1]) -- 配额
local window = tonumber(ARGV[2]) -- 时间窗口，其实就是某个 KEY 的过期时间
local current = redis.call("INCRBY", KEYS[1], 1)
if current == 1 then -- 说明还是初始化
    redis.call("expire", KEYS[1], window) 
    return 1
elseif current < limit then -- 时间窗口内，还有配额
    return 1
elseif current == limit then -- 时间窗口内，配额到达临界点
    return 2
else -- 时间窗口内，超过了配额
    return 0
end
```

计算时间窗口的函数

```go
func (h *PeriodLimit) calcExpireSeconds() int {
    // 如果 align 为 true 指，从 0 秒开始，每 align 秒为一个周期
    // 如果 align 为 false 指，从现在开始，每 align 秒为一个周期
	if h.align {
		unix := time.Now().Unix() + zoneDiff
		return h.period - int(unix%int64(h.period))
	} else {
		return h.period
	}
}
```

`periodlimit` 不过 100 来行代码，却能实现分布式限流，不愧是大佬

#### `tokenlimit` 令牌桶限流

同样先看看如何使用

```go
const (
    burst   = 100
    rate    = 100
    seconds = 5
)

store := redis.NewRedis("localhost:6379", "node", "")
fmt.Println(store.Ping())
// New tokenLimiter
limiter := limit.NewTokenLimiter(rate, burst, store, "rate-test")
timer := time.NewTimer(time.Second * seconds)
quit := make(chan struct{})
defer timer.Stop()
go func() {
  <-timer.C
  close(quit)
}()

var allowed, denied int32
var wait sync.WaitGroup
for i := 0; i < runtime.NumCPU(); i++ {
  wait.Add(1)
  go func() {
    for {
      select {
        case <-quit:
          wait.Done()
          return
        default:
          if limiter.Allow() {
            atomic.AddInt32(&allowed, 1)
          } else {
            atomic.AddInt32(&denied, 1)
          }
      }
    }
  }()
}

wait.Wait()
fmt.Printf("allowed: %d, denied: %d, qps: %d\n", allowed, denied, (allowed+denied)/seconds)
```

首先看看 `NewTokenLimiter()` 方法

```go
type TokenLimiter struct {
   rate           int // 每秒生成几个令牌
   burst          int // 令牌桶容量
   store          *redis.Redis
   tokenKey       string // 
   timestampKey   string
   rescueLock     sync.Mutex
   redisAlive     uint32
   rescueLimiter  *xrate.Limiter  // 兜底使用，内置限流
   monitorStarted bool
}

const (
	tokenFormat     = "{%s}.tokens"
	timestampFormat = "{%s}.ts"
)

// 返回一个新令牌桶限流器
func NewTokenLimiter(rate, burst int, store *redis.Redis, key string) *TokenLimiter {
   tokenKey := fmt.Sprintf(tokenFormat, key)
   timestampKey := fmt.Sprintf(timestampFormat, key)

   return &TokenLimiter{
      rate:          rate,
      burst:         burst,
      store:         store,
      tokenKey:      tokenKey,
      timestampKey:  timestampKey,
      redisAlive:    1, // 默认使用 redis
      rescueLimiter: xrate.NewLimiter(xrate.Every(time.Second/time.Duration(rate)), burst), // import xrate "golang.org/x/time/rate"
   }
}
```

接下来看 `Allow()`  方法

```go
// 对 reserveN() 方法的封装
func (lim *TokenLimiter) Allow() bool {
   return lim.AllowN(time.Now(), 1)
}
```

```go
// 对 reserveN() 方法的封装
func (lim *TokenLimiter) AllowN(now time.Time, n int) bool {
   return lim.reserveN(now, n)
}
```

```go
// 取得 n 条 token 令牌
func (lim *TokenLimiter) reserveN(now time.Time, n int) bool {
   // 兜底，如果 redis 不能用的话，就使用内置 rate 包限流
   if atomic.LoadUint32(&lim.redisAlive) == 0 {
      return lim.rescueLimiter.AllowN(now, n)
   }
 
   resp, err := lim.store.Eval(
      script, // 重点看看 script 脚本写的是什么，然后再往下看
      []string{
         lim.tokenKey,
         lim.timestampKey,
      },
      []string{
         strconv.Itoa(lim.rate),
         strconv.Itoa(lim.burst),
         strconv.FormatInt(now.Unix(), 10), // 如果每个服务器的时间不一致会出现什么情况，姑且认为每个服务器的时间是一致的吧
         strconv.Itoa(n),
      })
   // 出现错误？？？
   if err == redis.Nil {
      return false
   } else if err != nil {
      logx.Errorf("fail to use rate limiter: %s, use in-process limiter for rescue", err)
      // 看看这个
      lim.startMonitor()
      return lim.rescueLimiter.AllowN(now, n)
   }

   code, ok := resp.(int64)
   if !ok {
      logx.Errorf("fail to eval redis script: %v, use in-process limiter for rescue", resp)
      lim.startMonitor()
      return lim.rescueLimiter.AllowN(now, n)
   }

   // redis allowed == true
   // Lua boolean true -> r integer reply with value of 1
   return code == 1
}
```

script 代码

```lua
local rate = tonumber(ARGV[1]) -- 每秒生成多少个令牌
local capacity = tonumber(ARGV[2]) -- 令牌桶容量
local now = tonumber(ARGV[3]) -- 现在的时间戳
local requested = tonumber(ARGV[4]) -- 需要获取多少个令牌
local fill_time = capacity/rate -- 令牌桶容量/每秒生成多少个令牌 = 将令牌桶填满的时间
local ttl = math.floor(fill_time*2) -- 将令牌桶填满的时间 * 2 再向下取整
-- 如果令牌桶还未初始化，则剩余 令牌桶容量 个令牌
local last_tokens = tonumber(redis.call("get", KEYS[1])) -- KEYS1 : 令牌量的 KEY
if last_tokens == nil then
    last_tokens = capacity
end

-- 上次生成 token 时间
local last_refreshed = tonumber(redis.call("get", KEYS[2]))  -- KEYS2 : 令牌时间的 KEY
if last_refreshed == nil then
    last_refreshed = 0
end
-- 距离上次刷新时间过去了多少秒 -- 从而计算生成了多少个令牌
local delta = math.max(0, now-last_refreshed)
-- 计算还剩多少个令牌,  剩余多少个令牌 + 当前时间到上次刷新了多少令牌
local filled_tokens = math.min(capacity, last_tokens+(delta*rate))
-- 判断是否允许取得令牌
local allowed = filled_tokens >= requested
local new_tokens = filled_tokens
if allowed then
    new_tokens = filled_tokens - requested
end

redis.call("setex", KEYS[1], ttl, new_tokens) -- 将剩余令牌填写进去，并设置超时时间。如果时间超过将令牌桶填满的时间，则认为令牌桶是满的
redis.call("setex", KEYS[2], ttl, now) -- 将当前时间填写进去，并设置超时时间。如果时间超过将令牌桶填满的时间，则认为令牌桶是满的

return allowed 
```

```go
// 如果 redis 发生什么异常，则对 redis 进行监控
func (lim *TokenLimiter) startMonitor() {
   lim.rescueLock.Lock()
   defer lim.rescueLock.Unlock()

   if lim.monitorStarted {
      return
   }

   lim.monitorStarted = true
   atomic.StoreUint32(&lim.redisAlive, 0)

   go lim.waitForRedis()
}
// 如果 redis 变好了，则继续使用
// pingInterval = time.Millisecond * 100
func (lim *TokenLimiter) waitForRedis() {
   // 每 100 毫秒 ping 一下 redis, 如果 ping 通了，则修改 redis 状态
   ticker := time.NewTicker(pingInterval)
   defer func() {
      ticker.Stop()
      lim.rescueLock.Lock()
      lim.monitorStarted = false
      lim.rescueLock.Unlock()
   }()

   for range ticker.C {
      if lim.store.Ping() {
         atomic.StoreUint32(&lim.redisAlive, 1) //什么时候该使用 StoreUint32 什么时候直接赋值呢？
         return
      }
   }
}
```

