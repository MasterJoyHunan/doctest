### go-zero 中的 fx -- stream 流

类似于java中流式处理

先看看API

![image-20210323173220040](http://tc.masterjoy.top/typory/image-20210323173220040.png)

```GO

// 使用生成器生成 Stream
func From(generate GenerateFunc) Stream {
	source := make(chan interface{})
	
	// 如果生成器 painc, 这里可以 Recover, 最终关闭，防止内存泄漏
	threading.GoSafe(func() {
		defer close(source)
		generate(source)
	})
	// 最后都是使用了 channel
	return Range(source)
}

// 使用参数生成 Stream
func Just(items ...interface{}) Stream {
	source := make(chan interface{}, len(items))
	for _, item := range items {
		source <- item
	}
	close(source)
	// 最后都是使用了 channel
	return Range(source)
}

// 使用 channel 生成 Stream
func Range(source <-chan interface{}) Stream {
	return Stream{
		source: source,
	}
}

```

再来看看 Stream 这个 struct 吧
```go
type Stream struct {
	source <-chan interface{}
}
```
其实也没什么，只不过对 channel 包装了一层， 看看 Stream 的方法

![image-20210323173136151](http://tc.masterjoy.top/typory/image-20210323173136151.png)

哦吼，方法还有点多，一个一个看吧

Buffer 缓冲


```go
// Buffer 很简单，将 Stream 修改为带缓冲的 channel 
func (p Stream) Buffer(n int) Stream {
	if n < 0 {
		n = 0
	}

	source := make(chan interface{}, n)
	go func() {
		for item := range p.source {
			source <- item
		}
		close(source)
	}()
	return Range(source)
}
```

下一个 Count 计数

```go
// Count 也很简单，计算 Stream 流内的元素有多少个。
func (p Stream) Count() (count int) {
	for range p.source {
		count++
	}
	return
}
```

下一个 Distinct 去重

```go
// 对 Stream 里的值以什么方式加工
type KeyFunc func(item interface{}) interface{}

// 去重
func (p Stream) Distinct(fn KeyFunc) Stream {
	source := make(chan interface{})

	threading.GoSafe(func() {
		defer close(source)

         // 去重的好办法，使用 map 的 key 必须唯一这种方式
		keys := make(map[interface{}]lang.PlaceholderType)
        
		for item := range p.source {
			key := fn(item) // 使用 KeyFunc 方法 
			if _, ok := keys[key]; !ok {
				source <- item
				keys[key] = lang.Placeholder
			}
		}
	})

	return Range(source)
}
```

Done 方法阻塞线程 等待 channel 关闭

```go
func (p Stream) Done() {
	for range p.source {
	}
}
```

Filter 过滤

```go
// 对 Stream 里的值做判断，从而实现过滤工作
type FilterFunc func(item interface{}) bool

func (p Stream) Filter(fn FilterFunc, opts ...Option) Stream {
    // Walk 方法在下面细说
	return p.Walk(func(item interface{}, pipe chan<- interface{}) {
		if fn(item) {
			pipe <- item
		}
	}, opts...)
}
```

ForAll、ForEach 循环，这个两个很简单，就不解释了

```go
type ForAllFunc func(pipe <-chan interface{})

func (p Stream) ForAll(fn ForAllFunc) {
	fn(p.source)
}


type ForEachFunc func(item interface{})

func (p Stream) ForEach(fn ForEachFunc) {
	for item := range p.source {
		fn(item)
	}
}

```

Group 分组

```go
// KeyFunc 上面有介绍 
func (p Stream) Group(fn KeyFunc) Stream {
    // 其实就是使用 map 的特性
	groups := make(map[interface{}][]interface{})
	for item := range p.source {
		key := fn(item)
		groups[key] = append(groups[key], item)
	}

	source := make(chan interface{})
	go func() {
		for _, group := range groups {
			source <- group
		}
		close(source)
	}()

	return Range(source)
}
```

Head 取头N条

```go
func (p Stream) Head(n int64) Stream {
   if n < 1 {
      panic("n must be greater than 0")
   }

   source := make(chan interface{})

   go func() {
      for item := range p.source {
         n--
         if n >= 0 {
            source <- item
         }
         if n == 0 {
            close(source)
         }
      }
      // 有可能 Stream 被关闭了但是 Stream 里的 item 数量不够，那就直接关闭
      if n > 0 {
         close(source)
      }
   }()

   return Range(source)
}
```

Map 转换

```go
// 类似 Filter ，这里也使用了 Walk
func (p Stream) Map(fn MapFunc, opts ...Option) Stream {
   return p.Walk(func(item interface{}, pipe chan<- interface{}) {
      pipe <- fn(item)
   }, opts...)
}
```

Merge 合并

```go
// 将 Stream 中所有的 item 合并返回
func (p Stream) Merge() Stream {
   var items []interface{}
   for item := range p.source {
      items = append(items, item)
   }

   source := make(chan interface{}, 1)
   source <- items
   close(source)

   return Range(source)
}
```

Parallel 并行

```go
type ParallelFunc func(item interface{})

func (p Stream) Parallel(fn ParallelFunc, opts ...Option) {
   // 又见 Walk
   p.Walk(func(item interface{}, pipe chan<- interface{}) {
      fn(item)
   }, opts...).Done()
}
```

Reduce 对 Stream 求值

```go
type ReduceFunc func(pipe <-chan interface{}) (interface{}, error)

func (p Stream) Reduce(fn ReduceFunc) (interface{}, error) {
   return fn(p.source)
}
```

Reverse 翻转 Stream 

```go
func (p Stream) Reverse() Stream {
   var items []interface{}
   // 取出所有 item, 以数组存放
   for item := range p.source {
      items = append(items, item)
   }
   // 将数组翻转
   for i := len(items)/2 - 1; i >= 0; i-- {
      opp := len(items) - 1 - i
      items[i], items[opp] = items[opp], items[i]
   }
   // 返回一个新的 Stream
   return Just(items...)
}
```

Sort 排序

```go
type LessFunc func(a, b interface{}) bool

func (p Stream) Sort(less LessFunc) Stream {
   var items []interface{}
   // 和 Reverse 一样，先取出所有
   for item := range p.source {
      items = append(items, item)
   }
   // 然后使用内置排序方法，进行排序
   sort.Slice(items, func(i, j int) bool {
      return less(items[i], items[j])
   })
   // 和 Reverse 一样，返回一个新的 Stream
   return Just(items...)
}
```

Split 对 Stream 以 n 个为单位进行分割

```go
func (p Stream) Split(n int) Stream {
   if n < 1 {
      panic("n should be greater than 0")
   }

   source := make(chan interface{})
   go func() {
      var chunk []interface{}
      // 这里就不解释了
      for item := range p.source {
         chunk = append(chunk, item)
         if len(chunk) == n {
            source <- chunk
            chunk = nil
         }
      }
      // 如果 channel 关闭了，还是不满足，则将剩余的丢入新的 channel 中
      if chunk != nil {
         source <- chunk
      }
      close(source)
   }()
   // 返回新的 Stream
   return Range(source)
}
```

Tail 取后面的 n 条

```go
func (p Stream) Tail(n int64) Stream {
   if n < 1 {
      panic("n should be greater than 0")
   }

   source := make(chan interface{})

   go func() {
      // 顾名思义，就是一个环形数组
      ring := collection.NewRing(int(n))
      for item := range p.source {
         ring.Add(item)
      }
      for _, item := range ring.Take() {
         source <- item
      }
      close(source)
   }()

   return Range(source)
}
```

Walk 对 Stream 中所有的 item 进行操作

BOOS 您老到底做了什么

```go
func (p Stream) Walk(fn WalkFunc, opts ...Option) Stream {
   // 看下面
   option := buildOptions(opts...)
   if option.unlimitedWorkers {
      return p.walkUnlimited(fn, option)
   } else {
      return p.walkLimited(fn, option)
   }
}
```

```go
// 对 rxOptions 对象进行操作
type Option func(opts *rxOptions)

// 构造默认的 rxOptions ，如果有需要，可修改
func buildOptions(opts ...Option) *rxOptions {
   options := newOptions()
   for _, opt := range opts {
      opt(options)
   }
   return options
}
```

```go
func newOptions() *rxOptions {
   return &rxOptions{
      workers: defaultWorkers,
      // 默认 unlimitedWorkers: false
   }
}
```

```go
// 并发控制
type rxOptions struct {
   unlimitedWorkers bool // 不控制
   workers          int  // 如果控制，使用几个 worker
}
```

```go
// 常量
const (
   defaultWorkers = 16
   minWorkers     = 1
)
```

看看不做并发控制的代码

```go
type WalkFunc func(item interface{}, pipe chan<- interface{})

func (p Stream) walkUnlimited(fn WalkFunc, option *rxOptions) Stream {
     // 创建带缓冲的 channel
	pipe := make(chan interface{}, defaultWorkers)

     // 异步执行
	go func() {
		var wg sync.WaitGroup

		for {
             // 循环从 Stream 中取出一个 item
             // ok 是判断 channel 是否关闭的，如果关闭了，则退出循环
			item, ok := <-p.source
			if !ok {
				break
			}

			wg.Add(1)
			// 更安全的并发调用
			threading.GoSafe(func() {
				defer wg.Done()
				fn(item, pipe)
			})
		}

		wg.Wait()
		close(pipe)
	}()

	return Range(pipe)
}
```

如果做并发控制呢，并发控制有哪些应用场景呢？

```go
func (p Stream) walkLimited(fn WalkFunc, option *rxOptions) Stream {
   // 同上
   pipe := make(chan interface{}, option.workers)

   go func() {
      var wg sync.WaitGroup

      // 关键代码 1
      pool := make(chan lang.PlaceholderType, option.workers)

      for {
         // 关键代码 2 ，如果这里没有做并发控制，则 Stream 加入了一条数据，就会执行下面的逻辑，虽然 pipe 是有缓冲的，但是是会生成多个 goroutine 并阻塞
         // goroutine。做了控制之后，只会在这里阻塞，减少启动 goroutine 开销
         pool <- lang.Placeholder 
         item, ok := <-p.source
         if !ok {
            <-pool
            break
         }

         wg.Add(1)
         threading.GoSafe(func() {
            defer func() {
               wg.Done()
               // 关键代码 3
               <-pool
            }()

            fn(item, pipe)
         })
      }

      wg.Wait()
      close(pipe)
   }()

   return Range(pipe)
}
```

总结

1. Stream 充分使用了链式操作
2. Stream 充分了使用 channel 这种数据结构来进行数据交互（也就可以说并发安全）
3. GO将来发布泛型，这里肯定会重写吧

