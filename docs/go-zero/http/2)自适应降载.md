从何处执行了自适应降载

```go
func newEngine(c RestConf) *engine {
	srv := &engine{
		conf: c,
	}
	if c.CpuThreshold > 0 {
        // 重点
		srv.shedder = load.NewAdaptiveShedder(load.WithCpuThreshold(c.CpuThreshold))
		srv.priorityShedder = load.NewAdaptiveShedder(load.WithCpuThreshold(
			(c.CpuThreshold + topCpuUsage) >> 1))
	}
	return srv
}
```
降载核心结构体
```go
type adaptiveShedder struct {
    cpuThreshold    int64 // 阈值 -- 超过这个阈值才能触发降载
    windows         int64 // 计算每秒可以放行多少个 (10)
    flying          int64
    avgFlying       float64
    avgFlyingLock   syncx.SpinLock
    dropTime        *syncx.AtomicDuration // 最近丢请求时间
    droppedRecently *syncx.AtomicBool // 最近是否丢请求时间
    passCounter     *collection.RollingWindow 
    rtCounter       *collection.RollingWindow
}
type RollingWindow struct {
    lock          sync.RWMutex
    size          int // 单个时间窗口放行数量 (50)
    win           *window
    interval      time.Duration // 平均多少时间可以通过一个 (100毫秒)
    offset        int // 
    ignoreCurrent bool // 
    lastTime      time.Duration // start time of the last bucket
}
type SpinLock struct {
    lock uint32
}
type window struct {
	buckets []*Bucket
	size    int // 单个时间窗口放行数量
}
type Bucket struct {
	Sum   float64
	Count int64
}
```

```go
func NewAdaptiveShedder(opts ...ShedderOption) Shedder {
    // 如果关闭自适应降载,则不控制
	if !enabled.True() {
		return newNopShedder()
	}

	options := shedderOptions{
		window:       defaultWindow, // time.Second * 5 -- 时间窗口
		buckets:      defaultBuckets, // 50 -- 单个时间窗口放行数量
		cpuThreshold: defaultCpuThreshold, // 900 -- 阈值
	}
    // 自定义配置,覆盖上面 options 的选项
	for _, opt := range opts {
		opt(&options)
	}
    // 计算平均多少时间可以通过一个 (5秒 / 50个, 大约 100 毫秒可以放行一个 )
	bucketDuration := options.window / time.Duration(options.buckets)
	return &adaptiveShedder{
		cpuThreshold:    options.cpuThreshold,  // 阈值 -- 超过这个阈值才能触发降载
        windows:         int64(time.Second / bucketDuration), // 计算每秒可以放行多少个 (10)
		dropTime:        syncx.NewAtomicDuration(), // 最近是否丢请求时间
		droppedRecently: syncx.NewAtomicBool(), // 最近是否有丢弃过请求
		passCounter: collection.NewRollingWindow(options.buckets, bucketDuration, collection.IgnoreCurrentBucket()),
		rtCounter: collection.NewRollingWindow(options.buckets, bucketDuration, collection.IgnoreCurrentBucket()),
	}
}
```

```go
// SheddingHandler returns a middleware that does load shedding.
func SheddingHandler(shedder load.Shedder, metrics *stat.Metrics) func(http.Handler) http.Handler {
	if shedder == nil {
		return func(next http.Handler) http.Handler {
			return next
		}
	}

	ensureSheddingStat()

	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			sheddingStat.IncrementTotal()
            // 核心
			promise, err := shedder.Allow()
			if err != nil {
				metrics.AddDrop()
				sheddingStat.IncrementDrop()
				logx.Errorf("[http] dropped, %s - %s - %s",
					r.RequestURI, httpx.GetRemoteAddr(r), r.UserAgent())
				w.WriteHeader(http.StatusServiceUnavailable)
				return
			}

			cw := &security.WithCodeResponseWriter{Writer: w}
			defer func() {
				if cw.Code == http.StatusServiceUnavailable {
					promise.Fail()
				} else {
					sheddingStat.IncrementPass()
					promise.Pass()
				}
			}()
			next.ServeHTTP(cw, r)
		})
	}
}

func ensureSheddingStat() {
	lock.Lock()
	if sheddingStat == nil {
		sheddingStat = load.NewSheddingStat(serviceType)
	}
	lock.Unlock()
}
```

计算CPU使用率......

```go

func init() {
	go func() {
        // 这里是为了防止内存溢出,而不直接使用 time.After() 详见:
		cpuTicker := time.NewTicker(cpuRefreshInterval)
		defer cpuTicker.Stop()
		allTicker := time.NewTicker(allRefreshInterval)
		defer allTicker.Stop()

		for {
			select {
			case <-cpuTicker.C:
				threading.RunSafe(func() {
                    // linux 系统下每 250 毫秒取一次 /proc/%d/cgroup 文件 (windows 系统无效)
					curUsage := internal.RefreshCpu()
					prevUsage := atomic.LoadInt64(&cpuUsage)
                    // 这个算法可以计算过去5分钟CUP负载的 滑动平均值
					usage := int64(float64(prevUsage)*beta + float64(curUsage)*(1-beta))
					atomic.StoreInt64(&cpuUsage, usage)
				})
			case <-allTicker.C:
                // 仅仅是打印,没必要细看
				printUsage()
			}
		}
	}()
}
```

是否可以通过

```go
func (as *adaptiveShedder) shouldDrop() bool {
    // 如果系统过载,或虽然目前不过载了,但是还需要等待确定一下
	if as.systemOverloaded() || as.stillHot() {
		if as.highThru() {
			flying := atomic.LoadInt64(&as.flying)
			as.avgFlyingLock.Lock()
			avgFlying := as.avgFlying
			as.avgFlyingLock.Unlock()
			msg := fmt.Sprintf(
				"dropreq, cpu: %d, maxPass: %d, minRt: %.2f, hot: %t, flying: %d, avgFlying: %.2f",
				stat.CpuUsage(), as.maxPass(), as.minRt(), as.stillHot(), flying, avgFlying)
			logx.Error(msg)
			stat.Report(msg)
			return true
		}
	}

	return false
}

// 最近有丢弃请求,且丢弃的时间小于1秒,则认为系统还是过载的
func (as *adaptiveShedder) stillHot() bool {
	if !as.droppedRecently.True() {
		return false
	}
	dropTime := as.dropTime.Load()
	if dropTime == 0 {
		return false
	}
	
	hot := timex.Since(dropTime) < coolOffDuration
    // 如果上次丢弃时间超过了1秒,则将最近丢弃请求的标志设为false
	if !hot {
		as.droppedRecently.Set(false)
	}

	return hot
}
```

```go
func (as *adaptiveShedder) highThru() bool {
	as.avgFlyingLock.Lock()
	avgFlying := as.avgFlying
	as.avgFlyingLock.Unlock()
	maxFlight := as.maxFlight()
	return int64(avgFlying) > maxFlight && atomic.LoadInt64(&as.flying) > maxFlight
}

func (as *adaptiveShedder) maxFlight() int64 {
	// windows = buckets per second
	// maxQPS = maxPASS * windows
	// minRT = min average response time in milliseconds
	// maxQPS * minRT / milliseconds_per_second
	return int64(math.Max(1, float64(as.maxPass()*as.windows)*(as.minRt()/1e3)))
}

func (as *adaptiveShedder) maxPass() int64 {
	var result float64 = 1

	as.passCounter.Reduce(func(b *collection.Bucket) {
		if b.Sum > result {
			result = b.Sum
		}
	})

	return int64(result)
}

func (as *adaptiveShedder) minRt() float64 {
	result := defaultMinRt

	as.rtCounter.Reduce(func(b *collection.Bucket) {
		if b.Count <= 0 {
			return
		}

		avg := math.Round(b.Sum / float64(b.Count))
		if avg < result {
			result = avg
		}
	})

	return result
}

func (rw *RollingWindow) Reduce(fn func(b *Bucket)) {
	rw.lock.RLock()
	defer rw.lock.RUnlock()

	var diff int
	span := rw.span()
	// ignore current bucket, because of partial data
	if span == 0 && rw.ignoreCurrent {
		diff = rw.size - 1
	} else {
		diff = rw.size - span
	}
	if diff > 0 {
		offset := (rw.offset + span + 1) % rw.size
		rw.win.reduce(offset, diff, fn)
	}
}

// rw.size = 单个时间窗口放行数量
func (rw *RollingWindow) span() int {
    // 上次请求到现在请求的时间 / 平均多少时间可以通过一个
    // 从而计算该段时间理论上通过了多少个请求, 然后将 size 减去理论值
	offset := int(timex.Since(rw.lastTime) / rw.interval)
	if 0 <= offset && offset < rw.size {
		return offset
	}

	return rw.size
}
func (w *window) reduce(start, count int, fn func(b *Bucket)) {
	for i := 0; i < count; i++ {
		fn(w.buckets[(start+i)%w.size])
	}
}
```

