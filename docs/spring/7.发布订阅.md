### 发布订阅的基本使用

定义一个 event 继承 ApplicationEvent

```java
public class MyEvent extends ApplicationEvent {

  public MyEvent(Object source) {
    super(source);
  }
}
```

定义一个监听器实现 ApplicationListener 接口,泛型为需要监听的 event

```java
@Component
public class MyListener1 implements ApplicationListener<MyEvent> {

  @Override
  public void onApplicationEvent(MyEvent event) {
    System.out.println("MyListener1 get : " + event);
  }
}
```

使用事件发布

```java
@Component
public class MyService {

  @Autowired
  private ApplicationEventPublisher eventPublisher;

  public void doSome() {
    System.out.println(" publishEvent ");
    eventPublisher.publishEvent(new MyEvent("MyService.doSome()"));
  }
}
```

输出结果

```java
publishEvent 
MyListener1 get : com.test.EventApplication$MyEvent[source=MyService.doSome()]
```

完整代码

```java
@Configuration
public class EventApplication {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EventApplication.class);
        MyService bean = context.getBean(MyService.class);
        bean.doSome();
    }


    static class MyEvent extends ApplicationEvent {

        public MyEvent(Object source) {
            super(source);
        }
    }

    @Component
    static class MyService {

        @Autowired
        private ApplicationEventPublisher eventPublisher;

        public void doSome() {
            System.out.println("publishEvent");
            eventPublisher.publishEvent(new MyEvent("MyService.doSome()"));
        }
    }

    @Component
    static class MyListener1 implements ApplicationListener<MyEvent> {

        @Override
        public void onApplicationEvent(MyEvent event) {
            System.out.println("MyListener1 get : " + event);
        }
    }

    @Component
    static class MyListener2 implements ApplicationListener<MyEvent> {

        @Override
        public void onApplicationEvent(MyEvent event) {
            System.out.println("MyListener2 get : " + event);
        }
    }
}
```

### 使用注解方式

```java
@Configuration
public class EventApplication2 {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EventApplication2.class);
        MyService bean = context.getBean(MyService.class);
        bean.doSome();
    }


    static class MyEvent extends ApplicationEvent {

        public MyEvent(Object source) {
            super(source);
        }
    }

    @Component
    static class MyService {

        @Autowired
        private ApplicationEventPublisher eventPublisher;

        public void doSome() {
            System.out.println(" publishEvent ");
            eventPublisher.publishEvent(new MyEvent("MyService.doSome()"));
        }
    }

    @Component
    static class MyListener{

        @EventListener
        public void getEvent1(MyEvent event) {
            System.out.println("getEvent1 get : " + event);
        }

        @EventListener
        public void getEvent2(MyEvent event) {
            System.out.println("getEvent2 get : " + event);
        }
    }
}
```

#### 使用 @EventListener 后会以什么样的方式加入到监听呢？

其核心原理就是分析所有 bean 上的所有方法，如果方法上有 @EventListener 注解，将会被包装成实现了 ApplicationListener 的对象，然后注册至 SpringApplication 的 listeners 成员变量中，在合适的时候，调用 onApplicationEvent() 方法，onApplicationEvent() 方法会反射调用 bean 的方法

```java
public static void main(String[] args) {
  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EventApplication4.class);
  MyService bean = context.getBean(MyService.class);

  for (String beanDefinitionName : context.getBeanDefinitionNames()) {
    Object bean1 = context.getBean(beanDefinitionName);
    for (Method method : bean1.getClass().getMethods()) {
      if (method.isAnnotationPresent(MyEventListener.class)) {
        context.addApplicationListener(new ApplicationListener<ApplicationEvent>() {
          @SneakyThrows
          @Override
          public void onApplicationEvent(ApplicationEvent event) {
            Class<?> parameterType = method.getParameterTypes()[0];
            if (parameterType.isAssignableFrom(event.getClass())) {
              method.invoke(bean1, event);
            }
          }
        });
      }
    }
  }

  bean.doSome();
  context.close();
}
```

### 事件是如何发布的呢

其核心就是 ApplicationEventMulticaster 接口，在 refresh() 方法中，有个 initApplicationEventMulticaster() 方法

```java
protected void initApplicationEventMulticaster() {
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
  	// 有自定义发布器就使用自定义的
		if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
			this.applicationEventMulticaster =
					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
			if (logger.isTraceEnabled()) {
				logger.trace("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
			}
		}
		else {
      // 没有就使用系统自带的 SimpleApplicationEventMulticaster
			this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
			if (logger.isTraceEnabled()) {
				logger.trace("No '" + APPLICATION_EVENT_MULTICASTER_BEAN_NAME + "' bean, using " +
						"[" + this.applicationEventMulticaster.getClass().getSimpleName() + "]");
			}
		}
	}
```



