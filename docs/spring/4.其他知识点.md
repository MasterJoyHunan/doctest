### FactoryBean 的使用

* FactoryBean  不是 BeanFactory 这是两种不同的东西
* FactoryBean 是用来创建 Bean 的, 而 BeanFactory 是容器
* FactoryBean 是用来制造创建过程比较复杂的 Bean, 如 SqlSessionFactory
* 被 FactoryBean 创建的 Bean 不会执行创建,依赖注入,Aware接口回调,前初始化
* BeanFactory 只会执行后初始化,因为后初始化会加入代理功能
* 被 FactoryBean 创建的 Bean 不会存储于 singletonObjects 成员中,而是存在于 factoryBeanObjectCache 成员中
* BeanFactory .getBean(), 按名字获取的是 bean 对象,如果需要获取到 FactoryBean 对象,需要在名字前加 `&`

```java
public class FBean1 implements BeanFactoryAware {

    private Bean2 bean2;

    @Autowired // 不会进行依赖注入
    public void wire(Bean2 bean2 ) {
        this.bean2 = bean2;
    }

    @Override // 不会执行
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        System.out.println("beanFactory" + beanFactory);
    }

    @PostConstruct // 不会进行初始化
    public void init() {
        System.out.println("init");
    }

    static class Bean2 {

    }
}
```

```java
@Component("bean1")
public class FactoryBean1 implements FactoryBean<FBean1> {

    @Override
    public FBean1 getObject() throws Exception {
        System.out.println("create FBean1()");
        return new FBean1();
    }

    @Override
    public Class<?> getObjectType() {
        return FBean1.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
```

```java
public class FactoryBeanApplication1 {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext context= new AnnotationConfigApplicationContext();
        context.registerBean(FactoryBean1.class);
        context.refresh();

        for (String beanDefinitionName : context.getBeanDefinitionNames()) {
            System.out.println(beanDefinitionName);
        }

        context.getBean("bean1");
    }
}
```

输出:

```bash
create FBean1()
```

