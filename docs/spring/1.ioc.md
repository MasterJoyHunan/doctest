java

### IOC : 控制反转
是一种思想，无需手动创建对象，由 spring 容器来帮我们创建对象，用的时候直接取IOC容器取获取即可

IOC是一个容器，存储的就是 bean 对象

### BeanFactory  (核心)

`BeanFactory` 是 `spring` 中的核心容器，默认实现为 `DefaultListableBeanFactory`, 其依赖关系如下

![image-20220330100856740](http://tc.masterjoy.top/typory/image-20220330100856740.png)

简单使用 BeanFactory 

```java

public class TestBeanFactory {
    public static void main(String[] args) {

        // 创建 BeanFactory 容器, 作为 spring 核心容器
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();

        // 为 DefaultListableBeanFactory 添加 bean 的定义 , BeanFactory 根据 bean 的定义 再来自动创建 bean
        // bean 定义 [class, scope, 初始化, 销毁方法]
        AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(TestBean.class).setScope(BeanDefinition.SCOPE_SINGLETON).getBeanDefinition();
        factory.registerBeanDefinition("a", beanDefinition);

        // 给 bean factory 添加一些常用的 post processor (只是注册,没有运行)
        AnnotationConfigUtils.registerAnnotationConfigProcessors(factory);

        // 针对 Bean post processor 需要调用 postProcessBeanFactory() 方法才能使用
        Map<String, BeanFactoryPostProcessor> beansOfType = factory.getBeansOfType(BeanFactoryPostProcessor.class);
        beansOfType.values().forEach(v -> v.postProcessBeanFactory(factory));

        // 上面正针对 BeanFactoryPostProcessor, 还有针对 BeanPostProcessor:before() BeanPostProcessor:after()
        Map<String, BeanPostProcessor> beansOfType1 = factory.getBeansOfType(BeanPostProcessor.class);
        beansOfType1.values().forEach(factory::addBeanPostProcessor);

        // 只有在需要的使用 bean factory 才会创建 bean 的实例 (懒加载)
        System.out.println(factory.getBean(A.class).getB());

        // 如果需要提前创建则需要调用 preInstantiateSingletons() 方法
        factory.preInstantiateSingletons();

        String[] beanDefinitionNames = factory.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
    }


    @Configuration
    static class TestBean {

        @Bean("aa")
        public A a() {
            return new A();
        }

        @Bean("bb")
        public B b() {
            return new B();
        }
    }

    static class A {

        @Autowired
        public B b;

        public B getB () {
            return b;
        }
    }


    static class B {

    }
}
```
#### 总结一下:

* bean factory 只是实现了一个简单的容器
* 不会主动调用 bean factroy post processor
* 不会主动调用 bean post processor
* 不会主动初始化单例
* 不会解析 `${}`, `#{}` 占位符

### 容器如何加载 bean 对象

#### xml 方式 (基于 classpath )

```java
public class ReadXmlApplication {

    public static void main(String[] args) {
        ClassPathXmlApplicationContext xmlApplicationContext = new ClassPathXmlApplicationContext("bean.xml");
        Bean2 bean = (Bean2) xmlApplicationContext.getBean("bean2");
        bean.getBean1().say();
    }

    static class Bean1 {
        public Bean1() {
            System.out.println("init bean1");
        }

        public void say () {
            System.out.println("this is bean1 say");
        }
    }

    static class Bean2 {

        public Bean2() {
            System.out.println("init bean2");
        }

        private Bean1 bean1;

        public Bean1 getBean1() {
            return bean1;
        }

        public void setBean1(Bean1 bean1) {
            this.bean1 = bean1;
        }
    }
}
```

#### xml 方式 (基于文件路径)

```java
public class ReadFileXmlApplication {

    public static void main(String[] args) {
        FileSystemXmlApplicationContext fileSystemXmlApplicationContext = new FileSystemXmlApplicationContext("F:\\www-java\\spring-to-use\\01-bean-factory\\src\\main\\resources\\bean.xml");
        fileSystemXmlApplicationContext.getBean(ReadXmlApplication.Bean2.class).getBean1().say();
    }
}
```

#### 解析xml 原理

为什么读取文件,就会在 `bean factory` 中实例化对应的 `bean` 呢,其实底层还是使用的是 `DefaultListableBeanFactory`

```java
public class RealXmlApplication {

    public static void main(String[] args) {
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();

        XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);

        reader.loadBeanDefinitions(new ClassPathResource("bean.xml"));

        factory.getBean(ReadXmlApplication.Bean2.class).getBean1().say();
    }
}
```

#### 基于注解的方式

```java
public class AnnotationConfigApplication {

    public static void main(String[] args) {
        AnnotationConfigApplicationContext annotationContext = new AnnotationConfigApplicationContext(Config.class);
        annotationContext.getBean(Bean2.class).getBean1().say();
    }


    @Configuration
    static class Config {

        @Bean
        public Bean1 bean1() {
            return new Bean1();
        }

        @Bean
        public Bean2 bean2(Bean1 bean1) {
            return new Bean2(bean1);
        }

    }


    static class Bean1 {
        public Bean1() {
            System.out.println("init bean1");
        }

        public void say () {
            System.out.println("this is bean1 say");
        }
    }

    static class Bean2 {

        private Bean1 bean1;


        public Bean2(Bean1 bean1) {
            System.out.println("init bean2");
            this.bean1 = bean1;
        }

        public Bean1 getBean1() {
            return bean1;
        }

    }
}
```

#### web 容器

```java

public class WebAnnotationApplication {

    public static void main(String[] args) {
        new AnnotationConfigServletWebServerApplicationContext(WebConfig.class);
    }

    @Configuration
    static class WebConfig {

        @Bean
        public ServletWebServerFactory servletWebServerFactory() {
            return new TomcatServletWebServerFactory();
        }

        @Bean
        public DispatcherServlet dispatcherServlet() {
            return new DispatcherServlet();
        }

        @Bean
        public DispatcherServletRegistrationBean registrationBean(DispatcherServlet dispatcherServlet) {
            return new DispatcherServletRegistrationBean(dispatcherServlet, "/");
        }

        @Bean("/hello")
        public Controller controller () {
            return (httpServletRequest, httpServletResponse) -> {
                httpServletResponse.getWriter().println("Hi");
                return null;
            };
        }
    }
}
```

#### spring-boot 容器

```java
@SpringBootApplication
public class BeanFactoryApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(BeanFactoryApplication.class, args);

        // 国际化
        String someKey = context.getMessage("some key", null, Locale.CHINA);

        // 资源文件
        Resource resource = context.getResource("classpath:some-file.xml");

        // 系统变量
        String property = context.getEnvironment().getProperty("server.port");

        // 发布订阅
        context.publishEvent(new SomeEvent(null));
    }
}
```


### bean post processor 增强 bean 的功能

需要实现 `InstantiationAwareBeanPostProcessor` , `DestructionAwareBeanPostProcessor` 接口, 这两个接口都继承了 `BeanPostProcessor` 接口

BeanPostProcessor 接口提供了如下方法

* `postProcessBeforeInitialization()`  -- 初始化之前执行
* `postProcessAfterInitialization()` -- 初始化之后执行
* `postProcessProperties()` -- 依赖注入时执行

`InstantiationAwareBeanPostProcessor` 接口提供了如下方法

* `postProcessBeforeInstantiation()` -- 实例化之前执行
* `postProcessAfterInstantiation()` -- 实例化之后执行

`DestructionAwareBeanPostProcessor` 接口提供了如下方法

* `postProcessBeforeDestruction()` 销毁之前执行

```java

@Component
public class MyBeanPostProcessor implements InstantiationAwareBeanPostProcessor, DestructionAwareBeanPostProcessor {
    @Override
    public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {
        if (beanName.equals("testComponent")) {
            System.out.println("销毁之前执行");
        }
    }

    @Override
    public Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName) throws BeansException {
        if (beanName.equals("testComponent")) {
            System.out.println("实例化之前执行, 如果返回对象,则会替换原来的 bean");
        }
        return null;
    }

    @Override
    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        if (beanName.equals("testComponent")) {
            System.out.println("实例化之后执行,如果返回 false, 则会跳过依赖注入");
        }
        return true;
    }

    @Override
    public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {
        if (beanName.equals("testComponent")) {
            System.out.println("依赖注入阶段执行,如 @Value");
        }
        return pvs;
    }

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        if (beanName.equals("testComponent")) {
            System.out.println("初始化之前执行, return 对象会替换原有的 bean");
        }
        return InstantiationAwareBeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        if (beanName.equals("testComponent")) {
            System.out.println("初始化之后执行, return 的对象会替换原有的 bean, 例如代理模式增强");
        }
        return InstantiationAwareBeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
    }
}
```

因此可对 bean 的生命周期扩展为

* 实例化之前 
* 实例化
* 实例化之后执行,如果返回 false, 则会跳过依赖注入
* 依赖注入阶段执行
* 依赖注入F:\Java\jdk1.8.0_271
* 初始化之前执行, return 对象会替换原有的 bean
* 初始化
* 初始化之后执行, return 的对象会替换原有的 bean
* 销毁之前执行
* 销毁

### bean factory 自动注入的原理

一般注入

```java
public class Application {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();

        context.registerBean("bean1", Bean1.class);
        context.registerBean("bean2", Bean2.class);
        context.registerBean("bean3", Bean3.class);
        context.registerBean("myConfig",  JavaConfig.class);

        // 用于解析 @Autowired @Value 注解, 但是光加这一行是没用的,还需要设置默认解析器
        context.registerBean(AutowiredAnnotationBeanPostProcessor.class);
        context.getDefaultListableBeanFactory().setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());

        // 通用 annotation 解析器, 处理 @Resource @PostConstruct @PreDestroy
        context.registerBean(CommonAnnotationBeanPostProcessor.class);

        // @ConfigurationProperties 后处理器
        ConfigurationPropertiesBindingPostProcessor.register(context);

        context.refresh();

        context.getBean(Bean1.class).getBean2().say();
        context.getBean(Bean1.class).getBean3().say();
        JavaConfig bean = context.getBean(JavaConfig.class);
        context.close();
    }
}
```

稍微底层点的

```java
public class AutowireApplication {

    public static void main(String[] args) {
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();

        factory.registerSingleton("bean2", new Bean2());
        factory.registerSingleton("bean3", new Bean3());

        // 配置解析器 解析 @Autowire @Value
        factory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());

        // 配置解析器 解析 ${some}
        factory.addEmbeddedValueResolver(new StandardEnvironment()::resolvePlaceholders);

        AutowiredAnnotationBeanPostProcessor processor = new AutowiredAnnotationBeanPostProcessor();
        processor.setBeanFactory(factory);

        Bean1 b1 = new Bean1();
        processor.postProcessProperties(null, b1, "bean1");
        System.out.println(b1);
    }
}
```

注入实际上做的

```java
public class AutowireApplication2 {

    public static void main(String[] args) throws NoSuchFieldException, NoSuchMethodException {
        DefaultListableBeanFactory factory = new DefaultListableBeanFactory();

        factory.registerSingleton("bean2", new Bean2());
        factory.registerSingleton("bean3", new Bean3());

        // AutowiredAnnotationBeanPostProcessor 的内部是如何自动注入 属性、方法、Value

        // 属性
        Field field = Bean1.class.getDeclaredField("bean2");
        // 依赖描述
        DependencyDescriptor dd1 = new DependencyDescriptor(field, true);
        // 解析依赖
        Object b2 = factory.doResolveDependency(dd1, null, null, null);

        // 方法
        Method method = Bean1.class.getDeclaredMethod("setBean3", Bean3.class);
        DependencyDescriptor dd2 = new DependencyDescriptor(new MethodParameter(method, 0), true);
        Object b3 = factory.doResolveDependency(dd2, null, null, null);

        // 找到对应的 bean 之后，直接将 bean set 到对应的属性即可
        System.out.println(b2);
        System.out.println(b3);
    }
}
```

#### bean factory post processor 如何扫描 annotation 并进行自动注入

##### 模拟 : @ComponentScan("com.test.mapper")

```java

public class ComponentApplication2 {

    public static void main(String[] args) throws IOException {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean("config", Config05.class);

        // 模拟扫描
        ComponentScan annotation = AnnotationUtils.findAnnotation(Config05.class, ComponentScan.class);
        String[] strings = annotation.basePackages();

        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory();
        BeanNameGenerator nameGenerator = new AnnotationBeanNameGenerator();

        for (String string : strings) {
            System.out.println(string);
            String path = "classpath*:" + string.replace(".", "/") + "/**/*.class";
            Resource[] resources = context.getResources(path);
            for (Resource resource : resources) {
                MetadataReader metadataReader = readerFactory.getMetadataReader(resource);
                System.out.println("class name : " + metadataReader.getClassMetadata().getClassName());
                System.out.println("class 是否有 Component 注解 : " + metadataReader.getAnnotationMetadata().hasAnnotation(Component.class.getName()));
                System.out.println("class 是否有 Component 派生注解 : " + metadataReader.getAnnotationMetadata().hasMetaAnnotation(Component.class.getName()));

                // 将扫描到的 class 加入到容器
                if (!(metadataReader.getAnnotationMetadata().hasAnnotation(Component.class.getName()) ||
                        metadataReader.getAnnotationMetadata().hasMetaAnnotation(Component.class.getName()))) {
                    continue;
                }
                AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition(metadataReader.getClassMetadata().getClassName()).getBeanDefinition();
                context.registerBeanDefinition(nameGenerator.generateBeanName(beanDefinition, context), beanDefinition);
            }
        }

        context.refresh();

        for (String beanDefinitionName : context.getBeanDefinitionNames()) {
            System.out.println(beanDefinitionName);
        }

        context.close();
    }
}
```

##### 模拟 : @Bean

```java
public class ComponentApplication3 {

    public static void main(String[] args) throws IOException {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean("config", Config06.class);

        // 读取 class 的元信息
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory();
        MetadataReader metadataReader = readerFactory.getMetadataReader(new ClassPathResource("com/test/config/Config06.class"));

        // 获取class 所有方法上带有 @Bean 的方法
        Set<MethodMetadata> annotatedMethods = metadataReader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());
        annotatedMethods.forEach(v -> {
            BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition()
                    // 如果方法上还有注入信息,如: public Bean3 bean3(Bean1 bean1) ,还需要设置 AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR, 才能正确的进行依赖注入
                    .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR)
                    .setFactoryMethodOnBean(v.getMethodName(), "config");
            String initMethod = v.getAnnotationAttributes(Bean.class.getName()).get("initMethod").toString();

            // 如果 @Bean 上定义了 initMethod, 则需要在这里设置
            if (!initMethod.isEmpty()) {
                builder.setInitMethodName(initMethod);
            }
            AbstractBeanDefinition bd = builder.getBeanDefinition();

            // 将 BeanDefinition 信息注册到容器, 容器会在合适的时间实例化 bean
            context.registerBeanDefinition(v.getMethodName(), bd);
        });

        context.refresh();

        for (String beanDefinitionName : context.getBeanDefinitionNames()) {
            System.out.println(beanDefinitionName);
        }

        context.close();
    }
}
```

##### 模拟 : @MapperScan

```java
public class ComponentApplication4 {

    public static void main(String[] args) throws IOException {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean("config", Config07.class);
        // 解析 @Bean 注解
        context.registerBean(ConfigurationClassPostProcessor.class);

        // bean name 生成器
        AnnotationBeanNameGenerator nameGenerator = new AnnotationBeanNameGenerator();

        // 读取 class 的元信息
        MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory();
        MetadataReader metadataReader = readerFactory.getMetadataReader(new ClassPathResource("com/test/config/Config07.class"));
        AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();

        // 路径解析
        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();

        // 判断是否有 @MapperScan 注解,并获取注解里面属性:value, 根据 value 扫描对应的包路径
        if (annotationMetadata.hasAnnotation(MapperScan.class.getName())) {
            String[] scan = (String[]) annotationMetadata.getAnnotationAttributes(MapperScan.class.getName()).get("value");
            for (String string : scan) {
                readerFactory = new CachingMetadataReaderFactory();
                String tempPath = "classpath:" + string.replace(".", "/") + "/**/*.class";
                Resource[] resources = resolver.getResources(tempPath);

                // 获取到包路径下所有的 .class 文件后,继续获取是 interface 的文件,从而进行依赖注入
                for (Resource resource : resources) {
                    MetadataReader mapperReader = readerFactory.getMetadataReader(resource);

                    if (mapperReader.getClassMetadata().isInterface()) {
                        AbstractBeanDefinition bd = BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)
                                .addConstructorArgValue(mapperReader.getClassMetadata().getClassName())
                                .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)
                                .getBeanDefinition();
                        
                        // 不能使用 MapperFactoryBean 生成 bean name,否则会覆盖掉
                        AbstractBeanDefinition bdname = BeanDefinitionBuilder.genericBeanDefinition(mapperReader.getClassMetadata().getClassName())
                                .getBeanDefinition();
                        String name = nameGenerator.generateBeanName(bdname, context);
                        context.registerBeanDefinition(name, bd);
                    }
                }
            }
        }

        context.refresh();

        for (String beanDefinitionName : context.getBeanDefinitionNames()) {
            System.out.println(beanDefinitionName);
        }

        context.close();
    }
}
```

### 常用的 bean factory post  processor

```java
// 解析 @ComponentScan @Bean @Import @ImportResource
ConfigurationClassPostProcessor
context.registerBean(ConfigurationClassPostProcessor.class);
    
// 解析 @Autowire @Value
context.registerBean(AutowiredAnnotationBeanPostProcessor.class);
context.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver());
    
// 解析 ${some-propertise}
factory.addEmbeddedValueResolver(new StandardEnvironment()::resolvePlaceholders);

// 解析 @ConfigurationProperties 
ConfigurationPropertiesBindingPostProcessor.register(context);

// 解析 @Resource @PostConstruct @PreDestroy
context.registerBean(CommonAnnotationBeanPostProcessor.class);

// 解析 @Aspectj ,创建代理
context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);
```
### `Aware` 接口和 `InitializingBean` 接口

* `Aware` 是一个具有标识作用的超级接口，实现该接口的bean是具有被spring 容器通知的能力的，而被通知的方式就是通过回调。 也就是说：直接或间接实现了这个接口的类，都具有被spring容器通知的能力。 Spring Aware的目的是为了让Bean获得Spring容器的服务。
  * BeanNameAware 注入 bean 的名字
  * BeanFactoryAware 注入 BeanFactroy 容器
  * ApplicationContextAware 注入 ApplicationContext 容器
  * EmveddedValueResolverAware 解析 ${propertise}
* `InitializingBean` 接口

为什么有了 @Autowired 还需要 ApplicationContextAware、BeanFactoryAware 呢？

Aware 是 Spring 的内置功能，在任何情况下不会失效，但是 @Autowired 是 BeanFactoryPostProcessor 的扩展功能，在某些情况下，@Autowired 可能不会生效。

1. 没有注册 AutowiredAnnotationBeanPostProcessor 情况下，无法使用 @Autowired

2. Class 中注入了 @Bean BeanFactoryPostProcessor 情况下，无法使用 @Autowired

```java
@Configuration
public class Config002 {

    // 这种情况会失效
    @Autowired
    public void getApplicationContext(ApplicationContext applicationContext) {
        System.out.println(" getApplicationContext () ==> " + applicationContext);
    }

    // 这种情况会失效
    @PostConstruct
    public void init() {
        System.out.println("初始化 init() ==> ");
    }

	// 注入 BeanFactoryPostProcessor
    @Bean
    public BeanFactoryPostProcessor postProcessor1() {
        return beanFactory -> System.out.println("postProcessor1() ==> ");
    }
}
```
![image-20220401225312924](http://tc.masterjoy.top/typory/image-20220401225312924.png)

这和 refresh() 方法是执行顺序有关,如果需要获取到 BeanFactoryPostProcessor , 需要先实例化 Config002, 实例化之后,就不会进行 @Autowired 和 @PostConstruct 解析了

### 初始化和销毁的执行顺序

spring 中有3种初始化和3种销毁 bean 的方式,实际工作中可能只需要一种即可,这3种的执行顺序是什么样的呢

```java

public class Bean0001 implements InitializingBean, DisposableBean {

    @PostConstruct
    public void construct() {
        System.out.println("初始化方法 @PostConstruct 执行");
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("初始化方法 InitializingBean::afterPropertiesSet() 执行");
    }


    public void init() {
        System.out.println("初始化方法 @Bean(initMethod=init) 执行");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("销毁方法 @PreDestroy 执行");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("销毁方法 DisposableBean::destroy 执行");
    }

    public void close () {
        System.out.println("销毁方法 @Bean(initMethod=init) 执行");
    }
}
```

```java
@SpringBootApplication
public class InitApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext run = SpringApplication.run(InitApplication.class, args);
        run.close();
    }


    @Bean(initMethod = "init", destroyMethod = "close")
    public Bean0001 bean0001() {
        return new Bean0001();
    }
}
```

打印如下

```bash
初始化方法 @PostConstruct 执行
初始化方法 InitializingBean::afterPropertiesSet() 执行
初始化方法 @Bean(initMethod=init) 执行
销毁方法 @PreDestroy 执行
销毁方法 DisposableBean::destroy 执行
销毁方法 @Bean(initMethod=init) 执行
```

### Scope 的作用域

scope 在 spring5版本中有5种作用域
* singleton -- 单例 
* prototype -- 原型 多例模式
* request -- 请求 每次请求都不是同一个对象
* session -- 会话 
* application -- web application

#### 单例注入多例模式,多例会失效的解决办法

##### 使用@Lazy

```java
@Scope("prototype")
@Component
public class ScopeBean1 {
}

```

```java
@Component
public class ScopeConfig {

    @Lazy
    @Autowired
    private ScopeBean1 scopeBean1;
}
```

##### 使用 @Scope 的 proxyMode

```java
@Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
@Component
public class ScopeBean2 {
}

```

```java
@Component
public class ScopeConfig {

    @Autowired
    private ScopeBean2 scopeBean2;
}
```
##### 使用 ObjectFactory

```java
@Scope("prototype")
@Component
public class ScopeBean3 {
}
```

```java
@Component
public class ScopeConfig {
    @Autowired
    private ObjectFactory<ScopeBean3> scopeBean3;
    
    public ScopeBean3 getScopeBean3() {
        return scopeBean3.getObject();
    }
}
```
##### 使用 ApplicationContext

```java
@Scope("prototype")
@Component
public class ScopeBean4 {
}
```

```java
@Component
public class ScopeConfig {
    
    @Autowired
    private ApplicationContext applicationContext;

    public ScopeBean4 getScopeBean4() {
        return applicationContext.getBean(ScopeBean4.class);
    }
}
```
### 实例化与初始化


* 实例化 - 在堆中开辟一块内存空间，所有属性赋默认值
* 初始化 - 实例化后，所有属性赋设置的值，调用 `init-method` 初始化方法， 成为完整的 bean 对象

### PostProcessor

增强器/后置处理器，为了扩展而使用

* BeanFactoryPostProcessor
  * 加载 bean 配置使用，在 bean 对象实例化之前
  * 例：替换变量 ${jdbc.username}
* BeanPostProcessor
  * 实例化 bean 之后使用
  * bean 初始化之前调用 postProcessBeforeInitialization， 初始化之后调用 postProcessAfterInitialization

### Bean 的生命周期 

![image-20220328173534744](http://tc.masterjoy.top/typory/image-20220328173534744.png) 



### Environment

在容器创建的时候提前加载相关的属性到StanderdEnvironment对象中，方便后续使用

* env
  * 用于加载系统的环境变量 `System.getEnv()` 
  * 实现了 `Environment` 接口
* propertise
  * 用户加载自定义配置 `System.getPropertise()`

### 监听器，（观察者模式）

如果想想观察 bean 生命周期，

### AbstractApplicationContext 关键方法 refresh()

```java

    public void refresh() throws BeansException, IllegalStateException {
        synchronized(this.startupShutdownMonitor) {
            this.prepareRefresh();
            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();
            this.prepareBeanFactory(beanFactory);

            try {
                this.postProcessBeanFactory(beanFactory);
                this.invokeBeanFactoryPostProcessors(beanFactory);
                this.registerBeanPostProcessors(beanFactory);
                this.initMessageSource();
                this.initApplicationEventMulticaster();
                this.onRefresh();
                this.registerListeners();
                this.finishBeanFactoryInitialization(beanFactory);
                this.finishRefresh();
            } catch (BeansException var9) {
                if (this.logger.isWarnEnabled()) {
                    this.logger.warn("Exception encountered during context initialization - cancelling refresh attempt: " + var9);
                }

                this.destroyBeans();
                this.cancelRefresh(var9);
                throw var9;
            } finally {
                this.resetCommonCaches();
            }

        }
    }

```

### 解决循环依赖,三级缓存

循环依赖需要三级缓存

### BeanFactory 和 FactoryBean 区别

### ApplicationContext 的组成

![image-20220330100223269](http://tc.masterjoy.top/typory/image-20220330100223269.png)


* MessageSource -- 国际化相关
* ResourcePatternResolver -- 资源相关
* EnvironmentCapable -- 环境变量相关
* ApplicationEventPublisher -- 发布订阅相关

简单用法

```java
public class BeanFactoryApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(BeanFactoryApplication.class, args);

        // 国际化
        String someKey = context.getMessage("some key", null, Locale.CHINA);

        // 资源文件
        Resource resource = context.getResource("classpath:some-file.xml");

        // 系统变量
        String property = context.getEnvironment().getProperty("server.port");

        // 发布订阅
        context.publishEvent(new SomeEvent(null));
    }
}
```

