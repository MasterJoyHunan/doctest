### 使用 `aspectj` <编译时> 增强 `bean`

```xml
<!-- 加入对应的依赖 -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.8</version>
</dependency>

<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjrt</artifactId>
    <version>1.9.8</version>
</dependency>

<!-- 打包编译的时候加入对应的依赖 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
        <plugin>
            <groupId>org.codehaus.mojo</groupId>
            <artifactId>aspectj-maven-plugin</artifactId>
            <version>1.14.0</version>
            <configuration>
                <complianceLevel>1.8</complianceLevel>
                <source>8</source>
                <target>8</target>
                <showWeaveInfo>true</showWeaveInfo>
                <verbose>true</verbose>
                <Xlint>ignore</Xlint>
                <encoding>UTF-8</encoding>
            </configuration>
            <executions>
                <execution>
                    <goals>
                        <goal>compile</goal>
                        <goal>test-compile</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

```java
@Aspect
public class TestAspect {

    @Before("execution(* com.test.aspectj.TestBean.say())")
    public void before() {
        System.out.println("TestAspect::before()");
    }
}
```

```java
@Component
public class TestBean {

    public void say() {
        System.out.println("TestBean::say()");
    }
}
```

```java
@SpringBootApplication
public class UseAspectjApplication {

    public static void main(String[] args) {
        ConfigurableApplicationContext run = SpringApplication.run(UseAspectjApplication.class, args);
        run.getBean(TestBean.class).say();
    }
}
```

aspectj 增强的原理是在编译java 文件的时候,修改其 .class 文件,从而实现 AOP 增强

其优点是不依赖 spring 容器

如上 TestBean 被编译之后会变成

```java
@Component
public class TestBean {
    public TestBean() {
    }

    public void say() {
        TestAspect.aspectOf().before();
        System.out.println("TestBean::say()");
    }
}
```

### 使用 `aspectj` <类加载时> 增强 `bean`

```xml
<!-- 加入对应的依赖 (和上面的一样) -->
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.8</version>
</dependency>

<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjrt</artifactId>
    <version>1.9.8</version>
</dependency>

<!-- 无需像上面一样加入编译插件 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

和上面的编译时增强不同, 这里不需要 plugin 插件了,取而代之的是需要在启动程序的时候加上 JVM 参数 `-javaagent:C:/Users/Joy/.m2/repository/org/aspectj/aspectjweaver/1.9.8/aspectjweaver-1.9.8.jar`, 还需要配置 aop.xml 文件,放在resources/META-INF 文件夹下面

```xml
<!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd">
<aspectj>
    <aspects>
        <aspect name="com.test.aspectj.TestAspect2"/>
        <weaver options="-verbose -showWeaveInfo">
            <include within="com.test.aspectj..*"/>
        </weaver>
    </aspects>
</aspectj>
```

其他的和上面编译时增强一样

### 使用 `JDK` 代理增强

使用 jdk 代理增强 class 有几点需要注意

1. 需要增强的 class 必须实现某些接口才可以被代理
2. Jdk 是通过 ASM 技术来动态生成被代理的对象的
3. JDK 是通过反射调用，性能比较差
4. 反射重复调用 16 次，第 17 次会生成一个方法的代理对象(一个方法一个)，然后用对象调用

```java
public class AopJdkProxyApplication {

     public interface Switch {
         void push();
     }

     static class Off implements Switch {

         @Override
         public void push() {
             System.out.println("PUSH SWITCH TO OFF");
         }
     }

    public static void main(String[] args) throws IOException {
        // 动态生成字节码的技术 ASM
        Switch s = (Switch) Proxy.newProxyInstance(Off.class.getClassLoader(), new Class[]{Switch.class}, new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println("before");
                Off off = new Off();
                Object res = method.invoke(off, args);
                System.out.println("after");
                return res;
            }
        });
        s.push();
    }
}
```

JDK 代理是通过 ASM 技术动态生成 class 文件，生成的文件类似于下面的

```java
public class $SelfProxy0 implements Git {

    private InvocationHandler h;

    static Method push;
    static Method pull;

    static {
        try {
            push = Git.class.getMethod("push");
            pull = Git.class.getMethod("pull");
        } catch (NoSuchMethodException e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }

    public $SelfProxy0(InvocationHandler h) {
        this.h = h;
    }

    @Override
    public void push() {
        try {
            h.invoke(this, push, new Object[0]);
        } catch (RuntimeException | Error e) {
            throw e;
        } catch (Throwable e) {
            throw new UndeclaredThrowableException(e);
        }
    }

    @Override
    public int pull() {
        try {
            return (int) h.invoke(this, pull, new Object[0]);
        } catch (RuntimeException | Error e) {
            throw e;
        } catch (Throwable e) {
            throw new UndeclaredThrowableException(e);
        }
    }
}
```

```java
public interface InvocationHandler {

    Object invoke(Object o, Method method, Object[] args) throws Throwable;
}
```

```java
public interface Git {

    void push();

    int pull();
}

```

```java
public class GitImpl implements Git {
    @Override
    public void push() {
        System.out.println("git push >>>>>>>");
    }

    @Override
    public int pull() {
        System.out.println("git pull >>>>>>>");
        return 0;
    }
}
```



### 使用 `CGLIB` 代理增强

使用 CGLIB 代理增强 class 有几点需要注意

1. 需要增强的 class 必须不能是 final 的，因为 CGLIB 创建的代理对象需要继承被代理对象
2. CGLIB 是通过 ASM 技术来动态生成被代理的对象的
3. 使用对象调用，性能比反射调用高

基本使用

```java
public class Target1  {

    public void push() {
        System.out.println("PUSH SWITCH TO OFF");
    }
}
```

```java
public class AopCglibProxyApplication {

    public static void main(String[] args) {
        Target1 o = (Target1) Enhancer.create(Target1.class, new MethodInterceptor() {
            @Override
            public Object intercept(Object p, Method method, Object[] args, MethodProxy proxy) throws Throwable {

                System.out.println("before");
//                Object res = method.invoke(new Off(), args);
//                Object res = proxy.invoke(new Off(), args); // spring 用到的
                Object res = proxy.invokeSuper(p, args); // 最简洁
                System.out.println("after");
                return res;
            }
        });

        o.push();
    }
}

```

其原理就是通过 ASM 技术创建类似如下的代理对象

```java
public class $Proxy1 extends Target1 {

    static Method m1;
    static MethodProxy superM1;

    static {
        try {
            m1 = Target1.class.getMethod("push");
            // 关键
            superM1 = MethodProxy.create(Target1.class,  $Proxy1.class, "()V", "push", "pushSuper");
        } catch (NoSuchMethodException e) {
            throw new NoSuchMethodError(e.getMessage());
        }
    }

    private MethodInterceptor methodInterceptor;

    public void setMethodInterceptor(MethodInterceptor methodInterceptor) {
        this.methodInterceptor = methodInterceptor;
    }

    public void pushSuper() {
        super.push();
    }

    @Override
    public void push() {
        try {
            methodInterceptor.intercept(this, m1, new Object[0], superM1);
        } catch (Throwable e) {
            throw new UndeclaredThrowableException(e);
        }
    }
}
```

会生成两个methodProxy 对象, 继承 FastClass

一个是被代理对象的 methodProxy

```java
public class TargetFastClass {

    static Signature m1 = new Signature("push", "()V");

  	// 关键方法
    public int getIndex(Signature sig) {
        if (sig.equals(m1)) {
            return 0;
        } else {
            return -1;
        }
    }

		// 关键方法
    public Object invoke(int index, Object target, Object[] args) {
        if (index == 0) {
             ((Target1) target).push();
             return null;
        } else {
            throw new RuntimeException("没有对应的方法");
        }
    }
}

```

一个代理对象的class

```java
public class ProxyFastClass {

    static Signature m1 = new Signature("pushSuper", "()V");

  	// 关键方法
    public int getIndex(Signature sig) {
        if (sig.equals(m1)) {
            return 0;
        } else {
            return -1;
        }
    }

  	// 关键方法
    public Object invoke(int index, Object proxy, Object[] args) {
        if (index == 0) {
            (($Proxy1) proxy).pushSuper();
            return null;
        } else {
            throw new RuntimeException("没有对应的方法");
        }
    }
}
```

### AOP 的切点，通知，切面

* 切点 = 切入的点 （某个方法，多个方法）
* 通知 = 执行的动作 （前置通知，后置通知）
* 切面 = 切点 + 通知

#### 定义一个切点 `Pointcut`

1. 对方法做一个切点

```java
AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
pointcut.setExpression("execution(* foo())");
```

2. 对注解做一个切点

```java
AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
pointcut.setExpression("@annotation(org.springframework.transaction.annotation.Transactional)");
```

#### 定义通知 (实现 MethodInterceptor 接口)

```java
MethodInterceptor advice = new MethodInterceptor() {
    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
      System.out.println("before ...");
      Object proceed = invocation.proceed();
      System.out.println("after ...");
      return proceed;
    }
};
```

#### 切点和通知绑定，合成切面 `advisor`

```java
DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice);
```

#### 创建代理对象

```java
ProxyFactory proxyFactory = new ProxyFactory();
proxyFactory.setTarget(new MyServiceImpl1());
proxyFactory.addAdvisor(advisor);
MyService1 proxy = (MyService1) proxyFactory.getProxy();
proxy.foo();
```

#### 基本使用

```java
public class SpringAopApplication {

    public static void main(String[] args) {

        // 切点 Pointcut 接口
        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
        pointcut.setExpression("execution(* foo())");

        // 通知 MethodInterceptor 接口
        MethodInterceptor advice = new MethodInterceptor() {
            @Override
            public Object invoke(MethodInvocation invocation) throws Throwable {
                System.out.println("before ...");
                Object proceed = invocation.proceed();
                System.out.println("after ...");
                return proceed;
            }
        };

        // 合成切面 Advisor 接口
        DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice);

        /* 创建代理
         * 如果 ProxyConfig.proxyTargetClass = false, 且 target 实现了接口 则用 JDK 实现代理
         * 如果 ProxyConfig.proxyTargetClass = false, 且 target 没有实现接口 则用 CGLIB 实现代理
         * 如果 ProxyConfig.proxyTargetClass = true, 则始终用 CGLIB 实现代理
         */
        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.setTarget(new MyServiceImpl1());
        proxyFactory.addAdvisor(advisor);

        // 需要设置接口
        proxyFactory.setInterfaces(MyServiceImpl1.class.getInterfaces());

        // 设置 proxyTargetClass
        // proxyFactory.setProxyTargetClass(true);

        MyService1 proxy = (MyService1) proxyFactory.getProxy();
        System.out.println(proxy.getClass());

        proxy.foo();
        proxy.bar();
    }
}
```

### 不止在 method 上加注解，希望在 class 加注解，其 class 所有的 method 都可以使用

例如 @Transactional 注解，可以加到 interface 上， 可以加载 class 上

```java
@Transactional
public interface MyService1 {
    void foo();
    void bar();
}
```

```java
public class MyServiceImpl1 implements MyService1 {

    @Override
    public void foo() {
        System.out.println("foo");
    }

    @Transactional
    @Override
    public void bar() {
        System.out.println("bar");
    }
}
```

如何能自动识别这些方法呢？其实很简单

```java

public class SpringAopApplication2 {

    public static void main(String[] args) throws NoSuchMethodException {
        // 切点如何匹配 (匹配全局 方法,类,实现的接口,继承的类,如:Transactional)
        StaticMethodMatcherPointcut p1 = new StaticMethodMatcherPointcut() {

            @Override
            public boolean matches(Method method, Class<?> targetClass) {
                MergedAnnotations annotations = MergedAnnotations.from(method);
                if (annotations.isPresent(Transactional.class)) {
                    return true;
                }
                annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);
                if (annotations.isPresent(Transactional.class)) {
                    return true;
                }
                return false;
            }
        };
        System.out.println(p1.matches(MyServiceImpl1.class.getMethod("foo"), MyServiceImpl1.class));
        System.out.println(p1.matches(MyServiceImpl1.class.getMethod("bar"), MyServiceImpl1.class));
    }
}

```

### 高级 Aspect 与 低级 Advisor

####  高级切面 Aspect 特点

1. Aspect 是我们常用的使用方式，使用 @Aspect 注解即可使用
2. Aspect 是包含了一组或多组 Advisor 切面
3. Aspect 最终还是会转换成 Advisor 切面

```java
@Aspect // 高级切面
public class MyAspect {

    @Before("execution(* foo())")
    public void before() {
        System.out.println("before ... ");
    }


    @After("execution(* foo())")
    public void after() {
        System.out.println("after ... ");
    }
}
```

使用

```java
public class SpringAopApplication3 {

    public static void main(String[] args) throws NoSuchMethodException {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(MyServiceImpl1.class);
        context.registerBean(MyAspect.class);
        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);

        context.refresh();

        for (String beanDefinitionName : context.getBeanDefinitionNames()) {
            System.out.println(beanDefinitionName);
        }

        // 实现了接口的需要使用接口来获取对象
        MyService1 bean = context.getBean(MyService1.class);

        bean.foo();
        bean.bar();
    }
}

```

#### 低级切面 Advisor

```java
@Configuration // 低级切面
public class MyAdvisor {

    @Bean
    public MethodInterceptor advice() {
        return new MethodInterceptor() {

            @Override
            public Object invoke(MethodInvocation invocation) throws Throwable {
                System.out.println("before ...");
                Object res = invocation.proceed();
                System.out.println("after ...");
                return res;
            }
        };
    }

    @Bean
    public Advisor advisor(MethodInterceptor advice) {
        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
        pointcut.setExpression("execution(* bar())");
        return new DefaultPointcutAdvisor(pointcut, advice);
    }
}
```

#### AnnotationAwareAspectJAutoProxyCreator 的关键信息

![image-20220407090745596](http://tc.masterjoy.top/typory/image-20220407090745596.png)

* `findEligibleAdvisors(Class<?> beanClass, String beanName)` -- 查找所有符合条件的 advisor (bean 的切点匹配了对应的 advisor) 
  * 如果对应的 bean 做了对应的切面,默认系统会有一个 Advisor
  
  * 低级切面一个class 算一个
  
  * 高级切面 一个@before/@after/... 算一个
  
```java
package org.springframework.aop.framework.autoproxy; // 同包下
public class TestProxyCreator {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(MyServiceImpl1.class);
        context.registerBean(MyAspect.class);
        context.registerBean(MyAdvisor.class);

        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);
        context.registerBean(ConfigurationClassPostProcessor.class);

        context.refresh();

        AnnotationAwareAspectJAutoProxyCreator autoProxyCreator = context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);
        List<Advisor> s1 = autoProxyCreator.findEligibleAdvisors(MyService1.class, "s1");
        s1.forEach(v ->  System.out.println(v));
    }
}
```

* `wrapIfNecessary(Object bean, String beanName, Object cacheKey)` -- 查看某个 bean 是否有必要代理,如果需要则创建代理
```java
package org.springframework.aop.framework.autoproxy;  // 同包下
public class TestProxyCreator {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(MyServiceImpl1.class);
        context.registerBean(MyAspect.class);
        context.registerBean(MyAdvisor.class);

        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);
        context.registerBean(ConfigurationClassPostProcessor.class);

        context.refresh();
        
        Object o = autoProxyCreator.wrapIfNecessary(new MyServiceImpl1(), "s1", "s1");
        ((MyService1) o).foo();
        ((MyService1) o).bar();
    }
}
```

### 代理对象创建时机

创建 -> (proxy create)  依赖注入 -> 初始化 (proxy create)

#### 在单向依赖的情况下,代理对象是在初始化之后创建的

```java
public class SpringAopApplication4 {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(Config10.class);
        context.registerBean(MyAspect.class);

        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);
        context.registerBean(ConfigurationClassPostProcessor.class);
        context.registerBean(AutowiredAnnotationBeanPostProcessor.class);
        context.registerBean(CommonAnnotationBeanPostProcessor.class);

        context.refresh();
    }
}
```

```java
@Configuration
public class Config10 {

    @Bean
    public Bean1 bean1() {
        return new Bean1();
    }

    @Bean
    public Bean2 bean2() {
        return new Bean2();
    }

    static class Bean1 {
        public void foo() {
            System.out.println("Bean1 foo()");
        }

        public Bean1() {
            System.out.println("construct Bean1");
        }

        @PostConstruct
        public void init() {
            System.out.println("init Bean1");
        }
    }

    static class Bean2 {
        public Bean2() {
            System.out.println("construct Bean2");
        }

        @PostConstruct
        public void init() {
            System.out.println("init Bean2");
        }

        @Autowired
        private void autowire(Bean1 bean1) {
            System.out.println("autowire Bean1 :" + bean1.getClass());
        }
    }
}
```

打印结果 (在初始化之后生成)

```bash
construct Bean1
init Bean1
<生成代理对象>
construct Bean2
autowire Bean1 :class com.test.config.Config10$Bean1$$EnhancerBySpringCGLIB$$970ec6f5
init Bean2
```

#### 在循环依赖的情况下,代理对象是在依赖注入之前创建的

```java
public class SpringAopApplication5 {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(Config11.class);
        context.registerBean(MyAspect.class);

        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);
        context.registerBean(ConfigurationClassPostProcessor.class);
        context.registerBean(AutowiredAnnotationBeanPostProcessor.class);
        context.registerBean(CommonAnnotationBeanPostProcessor.class);

        context.refresh();
    }
}
```

```java
@Configuration
public class Config11 {

    @Bean
    public Bean1 bean1() {
        return new Bean1();
    }

    @Bean
    public Bean2 bean2() {
        return new Bean2();
    }

    static class Bean1 {
        public void foo() {
            System.out.println("Bean1 foo()");
        }

        public Bean1() {
            System.out.println("construct Bean1");
        }

        @Autowired
        private void autowire(Bean2 bean2) {
            System.out.println("autowire Bean2 :" + bean2.getClass());
        }

        @PostConstruct
        public void init() {
            System.out.println("init Bean1");
        }
    }

    static class Bean2 {
        public Bean2() {
            System.out.println("construct Bean2");
        }

        @PostConstruct
        public void init() {
            System.out.println("init Bean2");
        }

        @Autowired
        private void autowire(Bean1 bean1) {
            System.out.println("autowire Bean1 :" + bean1.getClass());
        }
    }
}
```

输出结果 (在依赖注入之前生成代理对象)

```bash
construct Bean1
construct Bean2
<生成代理对象>
autowire Bean1 :class com.test.config.Config11$Bean1$$EnhancerBySpringCGLIB$$12037742
init Bean2
autowire Bean2 :class com.test.config.Config11$Bean2
init Bean1
```

#### 总结

1. 代理在无循环依赖的时候,会在初始化之后创建
2. 代理在有循环依赖的时候,会在依赖注入之前创建,并暂存二级缓存
3. 在依赖注入阶段和初始化阶段, bean 对象不应该被增强

### 高级 `Aspect` 转低级 `Advisor`

```java
public class SpringAopApplication6 {

    public static void main(String[] args) {

        List<Advisor> advisorList = new ArrayList<>();

        AspectInstanceFactory factory = new SingletonAspectInstanceFactory(new MyAspect());

        // 找到对应的 @before @after ....
        for (Method method : MyAspect.class.getDeclaredMethods()) {

            // 判断方法上是否有 @before @after .... 注解
            if (method.isAnnotationPresent(Before.class)) {
                String value = method.getAnnotation(Before.class).value();

                // 定义一个切点
                AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
                pointcut.setExpression(value);

                // 定义一个通知
                AspectJMethodBeforeAdvice advice = new AspectJMethodBeforeAdvice(method, pointcut, factory);

                // 组合成切面
                DefaultPointcutAdvisor advisor = new DefaultPointcutAdvisor(pointcut, advice);

                // 加入集合
                advisorList.add(advisor);
            }

            // 判断方法上是否有 @before @after .... 注解
            if (method.isAnnotationPresent(After.class)) {}
        }

        advisorList.forEach(System.out::println);
    }
}
```

### 通知转换

所有的 advisor 都需要 proxyFactory 进行调用,在调用的时候,会把所有的通知转换为环绕通知 (适配器模式)

#### 所有通知转换为 `MethodInterceptor

* @Before 转换为 AspectJMethodBeforeAdvice, 没有实现 `MethodInterceptor` 接口
* @After 转换为 AspectJAfterAdvice, 实现了 `MethodInterceptor` 接口
* @Around 转换为 AspectJAroundAdvice, 实现了 `MethodInterceptor` 接口
* @AfterReturning 转换为 AspectJAfterReturningAdvice, 没有实现 `MethodInterceptor` 接口
* @AfterThrowing 转换为 AspectJAfterThrowingAdvice, 实现了 `MethodInterceptor` 接口

所以针对 @Before  @AfterReturning  需要进行转换 (适配器模式)

* @Before 转换为 MethodBeforeAdviceInterceptor
* @AfterReturning 转换为 AfterReturningAdviceInterceptor

### 通知调用 (调用链/责任链) MethodInvocation

```java
public class MyMethodInvocation implements MethodInvocation {

    private Method method;

    private Object target;

    private Object[] args;

    private List<MethodInterceptor> methodInterceptors;

    private int count = -1;

    public MyMethodInvocation(Object target, Method method, Object[] args,List<MethodInterceptor> methodInterceptors ) {
        this.target = target;
        this.method = method;
        this.args = args;
        this.methodInterceptors = methodInterceptors;
    }


    @Override
    public Method getMethod() {
        return method;
    }

    @Override
    public Object[] getArguments() {
        return args;
    }

  	// 关键方法
    @Override
    public Object proceed() throws Throwable {
        count ++;
        if (count == methodInterceptors.size()) {
            return method.invoke(target, args);
        }
        return methodInterceptors.get(count).invoke(this);
    }

    @Override
    public Object getThis() {
        return target;
    }

    @Override
    public AccessibleObject getStaticPart() {
        return method;
    }
}
```

调用执行

```java
public class SpringAopApplication8 {

    public static void main(String[] args) throws Throwable {
        List<MethodInterceptor> arr = new ArrayList<>();
        arr.add(invocation -> {
            System.out.println("before1 ...");
            Object res = invocation.proceed();
            System.out.println("after1 ....");
            return res;
        });
        arr.add(invocation -> {
            System.out.println("before2 ...");
            Object res = invocation.proceed();
            System.out.println("after2 ....");
            return res;
        });
        MyMethodInvocation invocation = new MyMethodInvocation(new MyServiceImpl1(), MyServiceImpl1.class.getMethod("foo"), null, arr);
        invocation.proceed();
    }
}
```

### 带参数的
