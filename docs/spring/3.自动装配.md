### 使用@Import导入第三方的配置 1

最简单的用法

```java
// 手动自动导入配置
public class ManualAutoConfigApplication {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(ConfigurationClassPostProcessor.class);
        context.registerBean(MyConfig.class);
        context.refresh();
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
    }

    // 自定义的配置类，导入第三方的配置
    @Configuration
    @Import({ThreePartConfig1.class, ThreePartConfig2.class})
    static class MyConfig{

    }

    // 第三方配置类
    @Configuration
    static class ThreePartConfig1 {
        @Bean("obj1")
        public Object object() {
            return new Object();
        }
    }

    // 第三方配置类
    @Configuration
    static class ThreePartConfig2{
        @Bean("obj2")
        public Object object() {
            return new Object();
        }
    }
}
```

### 使用@Import导入第三方的配置 2

相对于1 ，定义了一个实现了ImportSelector 的类，使用@import 加载该类，实现同样的效果

```java
static class MyImportSelector implements ImportSelector{
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        return new String[]{ThreePartConfig1.class.getName(), ThreePartConfig2.class.getName()};
    }
}
```

完整代码

```java

// 手动自动导入配置
public class ManualAutoConfigApplication2 {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(ConfigurationClassPostProcessor.class);
        context.registerBean(MyConfig.class);
        context.refresh();
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
    }

    // 自定义的配置类，导入关键类
    @Configuration
    @Import({MyImportSelector.class})
    static class MyConfig{

    }

  	// 关键类
    static class MyImportSelector implements ImportSelector{
        @Override
        public String[] selectImports(AnnotationMetadata importingClassMetadata) {
            return new String[]{ThreePartConfig1.class.getName(), ThreePartConfig2.class.getName()};
        }
    }

    // 第三方配置类
    @Configuration
    static class ThreePartConfig1 {
        @Bean("obj1")
        public Object object() {
            return new Object();
        }
    }

    // 第三方配置类
    @Configuration
    static class ThreePartConfig2{
        @Bean("obj2")
        public Object object() {
            return new Object();
        }
    }
}
```

### 使用@Import导入第三方的配置 3 

使用外部文件 META-INF/spring.factories 

相比于2，该方式将需要加入的配置放入了配置文件，无需修改代码

```txt
# 内部类需要使用$
com.test.ManualAutoConfigApplication3$MyImportSelector=\
com.test.ManualAutoConfigApplication3.ThreePartConfig1,\
com.test.ManualAutoConfigApplication3.ThreePartConfig2
```

完整代码

````java
// 手动自动导入配置
public class ManualAutoConfigApplication3 {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        context.registerBean(ConfigurationClassPostProcessor.class);
        context.registerBean(MyConfig.class);
        context.refresh();
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
    }

    // 自定义的配置类，导入第三方的配置
    @Configuration
    @Import({MyImportSelector.class})
    static class MyConfig{

    }

    static class MyImportSelector implements ImportSelector{
        @Override
        public String[] selectImports(AnnotationMetadata importingClassMetadata) {
          	// 关键代码
            List<String> strings = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, null);
            return strings.toArray(new String[0]);
        }
    }

    // 第三方配置类
    @Configuration
    static class ThreePartConfig1 {
        @Bean("obj1")
        public Object object() {
            return new Object();
        }
    }

    // 第三方配置类
    @Configuration
    static class ThreePartConfig2{
        @Bean("obj2")
        public Object object() {
            return new Object();
        }
    }
}

````

### 如果本项目和第三方出现相同的bean会怎么样

Spring-boot 默认情况下不允许出现两个相同的 bean, 但是可以设置 setAllowBeanDefinitionOverriding(false),达到有相同的bean不会报错，但是后生成的bean会将同名的bean覆盖

#### 本地bean 和 第三方谁先谁后生成

* 如果实现了 ImportSelector 接口，会先将第三方的 bean 生成，如果本项目有相同的bean ,则会覆盖第三方
* 如果实现了DeferredImportSelector 接口，则与上面相反

### 按条件生成 bean

#### @ConditionalOnMissingBean 是否缺少某个bean

在 @Bean 上添加 @ConditionalOnMissingBean 注解，可以让 bean 创建时判断，当没有该 bean 时才创建

Spring-boot 中，不允许同名被覆盖，但是本项目的 bean 的优先级是最高的，会被先解析，第三方会被后解析，所以第三方需要 实现 DeferredImportSelector 接口，且添加 @ConditionalOnMissingBean 注解

#### @ConditionalOnClass 是否含有某个 class

#### @ConditionalOnMissingClass 是否缺少某个 class

#### @ConditionalOnMissingClass 是否缺少某个 class

#### @ConditionalOnProperty 

子元素

* name -- 是否包含某个键名
* prefix -- 是否含有该前缀
* havingValue -- 值是否匹配
* matchIfMissing -- 是否没有该配置

### AOP自动配置的实现

```java
public class ManualAutoConfigApplication5 {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context);
        context.registerBean(MyConfig.class);
        context.refresh();
        String[] beanDefinitionNames = context.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
    }

    @Configuration
    @Import({MyImportSelector.class})
    static class MyConfig {
    }

    static class MyImportSelector implements ImportSelector {
        @Override
        public String[] selectImports(AnnotationMetadata importingClassMetadata) {
            // 重点
            return new String[]{AopAutoConfiguration.class.getName()};
        }
    }
}
```

查看 AopAutoConfiguration

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnProperty(prefix = "spring.aop", name = "auto", havingValue = "true", matchIfMissing = true)
public class AopAutoConfiguration {

	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Advice.class)
	static class AspectJAutoProxyingConfiguration {

		@Configuration(proxyBeanMethods = false)
		@EnableAspectJAutoProxy(proxyTargetClass = false)
		@ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "false",
				matchIfMissing = false)
		static class JdkDynamicAutoProxyConfiguration {

		}

         // 最终执行的,查看关键代码 @EnableAspectJAutoProxy
		@Configuration(proxyBeanMethods = false)
		@EnableAspectJAutoProxy(proxyTargetClass = true)
		@ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "true",
				matchIfMissing = true)
		static class CglibAutoProxyConfiguration {

		}

	}

	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingClass("org.aspectj.weaver.Advice")
	@ConditionalOnProperty(prefix = "spring.aop", name = "proxy-target-class", havingValue = "true",
			matchIfMissing = true)
	static class ClassProxyingConfiguration {

		ClassProxyingConfiguration(BeanFactory beanFactory) {
			if (beanFactory instanceof BeanDefinitionRegistry) {
				BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
				AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);
				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
			}
		}

	}

}
```

查看 @EnableAspectJAutoProxy

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
// 重点关注
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {

	boolean proxyTargetClass() default false;
	boolean exposeProxy() default false;

}
```

```java
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {

	@Override
	public void registerBeanDefinitions(
			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

         // 就是这里
		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

		AnnotationAttributes enableAspectJAutoProxy =
				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
		if (enableAspectJAutoProxy != null) {
			if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
				AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
			}
			if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
				AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
			}
		}
	}
}
```

```java
public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(
			BeanDefinitionRegistry registry, @Nullable Object source) {
	return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
}
```

### spring-boot 的自动配置

编写 spring-boot 的启动类时,会先在启动类上加上 @SpringBootApplication

```java
@SpringBootApplication
public class ManualAutoConfigApplication5 {

    public static void main(String[] args) {
    }
}
```

@SpringBootApplication 是一个组合注解里面,里面包含了@EnableAutoConfiguration 注解

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration //重点
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
    
}
```

其@EnableAutoConfiguration有是一个组合注解,里面包含了 @Import 注解,@Import 注解加载了 AutoConfigurationImportSelector 类

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage // 将当前包名导入到 context 容器
@Import(AutoConfigurationImportSelector.class) // 重点关注
public @interface EnableAutoConfiguration {
}
```

AutoConfigurationImportSelector 实现了 DeferredImportSelector 接口,所以所有的配置类是后加载的,默认情况下,spring-boot 不允许定义重复的bean,所以自动配置类需要加入各种条件,以防止报错

```java
												   // 后实例化						
public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,
		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {}
```

查看关键方法

```java
@Override
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    }
    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader
        .loadMetadata(this.beanClassLoader);
    
    // 关键
    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,
                                                                              annotationMetadata);
    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
}
```

```java
protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,
                                                           AnnotationMetadata annotationMetadata) {
    if (!isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    }
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // 关键
    List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
    configurations = removeDuplicates(configurations);
    Set<String> exclusions = getExclusions(annotationMetadata, attributes);
    checkExcludedClasses(configurations, exclusions);
    configurations.removeAll(exclusions);
    configurations = filter(configurations, autoConfigurationMetadata);
    fireAutoConfigurationImportEvents(configurations, exclusions);
    return new AutoConfigurationEntry(configurations, exclusions);
}
```

SpringFactoriesLoader.loadFactoryNames 是到 META-INF/spring.factories 文件中,根据某个键值取到对应的指

```java
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    // getSpringFactoriesLoaderFactoryClass 关键
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
                                                                         getBeanClassLoader());
    Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
                    + "are using a custom packaging, make sure that file is correct.");
    return configurations;
}
```

```java
protected Class<?> getSpringFactoriesLoaderFactoryClass() {
    return EnableAutoConfiguration.class;
}
```

到此明白了,如果 META-INF/spring.factories 文件中,有 key 为 org.springframework.boot.autoconfigure.EnableAutoConfiguration 的值会自动被 spring 加载

### 条件装配的原理

```java
public class ManualAutoConfigApplication7 {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context);
        context.registerBean(MyConfig.class);
        context.refresh();

        System.out.println(">>>>>>>>>>>>>>>>>");
        String[] beanDefinitionNames = context.getBeanDefinitionNames();

        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
    }

    @Configuration
    static class MyConfig {

        @Bean("obj1")
        @Conditional(MyCondition1.class)
        public Object object1() {
            return new Object();
        }

        @Bean("obj2")
        @Conditional(MyCondition2.class)
        public Object object2() {
            return new Object();
        }
    }

    static class MyCondition1 implements Condition {

        @Override // 判断项目是否包含某个 class
        public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
            return ClassUtils.isPresent("com.test.condition.Test", null);
        }
    }

    static class MyCondition2 implements Condition {

        @Override// 判断项目是否不包含某个 class
        public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
            return !ClassUtils.isPresent("com.test.condition.Test", null);
        }
    }
}
```

自定义条件判断需要实现 Condition接口, 然后在 matches () 使用代码方式进行判断即可,上面的代码不是很间接,使用下方的代码更优雅

```java
public class ManualAutoConfigApplication8 {

    public static void main(String[] args) {
        GenericApplicationContext context = new GenericApplicationContext();
        AnnotationConfigUtils.registerAnnotationConfigProcessors(context);
        context.registerBean(MyConfig.class);
        context.refresh();

        System.out.println(">>>>>>>>>>>>>>>>>");
        String[] beanDefinitionNames = context.getBeanDefinitionNames();

        for (String beanDefinitionName : beanDefinitionNames) {
            System.out.println(beanDefinitionName);
        }
    }

    @Configuration
    static class MyConfig {

        @Bean("obj1")
        @ConditionalOnClass(className = "com.test.condition.Test")
        public Object object1() {
            return new Object();
        }

        @Bean("obj2")
        @ConditionalOnClass(className = "com.test.condition.Test", exist = false)
        public Object object2() {
            return new Object();
        }
    }

    @Target({ElementType.TYPE, ElementType.METHOD})
    @Retention(RetentionPolicy.RUNTIME)
    @Conditional(MyCondition1.class)
    @interface ConditionalOnClass {
        boolean exist() default true;

        String className();
    }

    static class MyCondition1 implements Condition {

        @Override // 判断项目是否包含某个 class
        public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
            Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnClass.class.getName());
            String className = attributes.get("className").toString();
            boolean exist = (boolean) attributes.get("exist");

            boolean present = ClassUtils.isPresent(className, null);
            return exist == present;
        }
    }
}
```

