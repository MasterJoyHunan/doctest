### 规范

性能测试的用例函数必须以Benchmark开头，例如BenchmarkXxx或Benchmark_Xxx（ Xxx 部分为任意字母数字组合，首字母大写）。

函数参数必须是*testing.B，函数内以b.N作为循环次数，其中N会在运行时动态调整，直到性能测试函数可以持续足够长的时间，以便能够可靠地计时。下面的代码是一个简单的性能测试函数

```go
func BenchmarkRandInt(b *testing.B) {
    for i := 0; i < b.N; i++ {
        RandInt()
    }
}
```

go test命令默认不会执行性能测试函数，需要通过指定参数-bench 来运行性能测试函数。-bench后可以跟正则表达式，选择需要执行的性能测试函数，例如go test -bench=".*"表示执行所有的压力测试函数。执行go test -bench=".*"后输出如下

```bash
$ go test -bench=".*"
goos: linux
goarch: amd64
pkg: github.com/marmotedu/gopractise-demo/31/test
# 该3列的表示
BenchmarkRandInt-4      97384827                12.4 ns/op
PASS
ok      github.com/marmotedu/gopractise-demo/31/test    1.223s
```

* `BenchmarkRandInt-4` -- BenchmarkRandInt表示所测试的测试函数名，4 表示有 4 个 CPU 线程参与了此次测试，默认是GOMAXPROCS的值。
* `97384827` -- 说明函数中的循环执行了97384827次。
* `12.4 ns/op` -- 说明每次循环的执行平均耗时是 12.4 纳秒，该值越小，说明代码性能越高。

如果我们的性能测试函数在执行循环前，需要做一些耗时的准备工作，我们就需要重置性能测试时间计数

```go
func BenchmarkBigLen(b *testing.B) {
    big := NewBig() // 初始化一些操作，如果该操作需要很长时间
    b.ResetTimer() // 在这里重设计时器
    for i := 0; i < b.N; i++ {
        big.Len()
    }
}
```

也可以先停止性能测试的时间计数，然后再开始时间计数

```go
func BenchmarkBigLen(b *testing.B) {
  b.StopTimer() // 调用该函数停止压力测试的时间计数
  big := NewBig()
  b.StartTimer() // 重新开始时间
  for i := 0; i < b.N; i++ {
    big.Len()
  }
}
```

### 性能测试支持的参数

#### benchmem，输出内存分配统计

```bash
$ go test -bench=".*" -benchmem
goos: linux
goarch: amd64
pkg: github.com/marmotedu/gopractise-demo/31/test
BenchmarkRandInt-4      96776823                12.8 ns/op             0 B/op          0 allocs/op
PASS	
ok      github.com/marmotedu/gopractise-demo/31/test    1.255s
# 0 B/op         每次执行分配了多少内存（字节），该值越小，说明代码内存占用越小
# 0 allocs/op    表示每次执行分配了多少次内存，该值越小，说明分配内存次数越少，意味着代码性能越高
```


#### benchtime，指定测试时间和循环执行次数（格式需要为 Nx，例如 100x）
#### cpu，指定 GOMAXPROCS
#### timeout，指定测试函数执行的超时时间
