### GitHub Actions工作流

#### workflow

一个 .yml 文件对应一个 workflow，也就是一次持续集成。一个 GitHub 仓库可以包含多个 workflow，只要是在 .github/workflow 目录下的 .yml 文件都会被 GitHub 执行。

#### job

一个 workflow 由一个或多个 job 构成，每个 job 代表一个持续集成任务。

#### step

每个 job 由多个 step 构成，一步步完成。

#### action

每个 step 可以依次执行一个或多个命令（action）。

#### on

一个 workflow 的触发条件，决定了当前的 workflow 在什么时候被执行。

### workflow 文件基本使用

GitHub Actions 配置文件存放在代码仓库的.github/workflows目录下，文件后缀为.yml，支持创建多个文件，文件名可以任意取，比如iam.yml。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件，如果运行过程中存在问题，会以邮件的形式通知到你。

* name -- workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。

```yaml
name: GitHub Actions Demo
```

* on -- 指定触发 workflow 的条件，通常是某些事件。

```yaml
# 只有master分支发生push事件时，才会触发 workflow
on:
  push:
    branches:
      - master
```

* jobs.<job_id>.name -- job 任务的说明

```yaml
jobs:
  my_first_job:
    name: My first job # job 描述
  my_second_job:
    name: My second job
```

* jobs.<job_id>.needs -- job 任务所需要的依赖

```yaml
jobs:
  job1:
  job2: # job2 依赖 job1
    needs: job1
  job3: # job3 依赖 job1 和 job2
    needs: [job1, job2]
```

* jobs.<job_id>.runs-on -- 运行所需要的虚拟机环境，它是必填字段，目前可用：

ubuntu-latest、ubuntu-18.04 或 ubuntu-16.04。

windows-latest、windows-2019 或 windows-2016。

macOS-latest 或 macOS-10.14。.

```yaml
runs-on: ubuntu-18.04 # 指定虚拟机环境为ubuntu-18.04
```

* jobs.<job_id>.steps -- 指定每个 Job 的运行步骤 可以包含一个或多个，每个步骤都可以指定下面三个字段。
    * jobs.<job_id>.steps.name -- 步骤名称
    * jobs.<job_id>.steps.run -- 该步骤运行的命令或者 action
    * jobs.<job_id>.steps.env -- 该步骤所需的环境变量

下面是一个完整的 workflow 文件的范例：

```yaml
name: Greeting from Mona
on: push

jobs:
  my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
    - name: Print a greeting
      env:
        MY_VAR: Hello! My name is
        FIRST_NAME: Lingfei
        LAST_NAME: Kong
      run: |
        echo $MY_VAR $FIRST_NAME $LAST_NAME.
```

* uses -- 引用别人已经创建的 actions 引用格式为userName/repoName@verison，例如uses: actions/setup-go@v1。
* with -- 指定 actions 的输入参数。每个输入参数都是一个键 / 值对。输入参数被设置为环境变量，该变量的前缀为 INPUT_，并转换为大写。

```yaml
jobs:
  my_first_job:
    steps:
      - name: My first step
        uses: actions/hello_world@master
        with:
          first_name: Lingfei
          middle_name: Go
          last_name: Kong
```

* run -- 指定执行的命令。可以有多个命令，例如：

```yaml
- name: Build
      run: |
      go mod tidy
      go build -v -o helloci .
```

* id -- step 的唯一标识

### 进阶用法

#### 使用构建矩阵

如果我们想在多个系统或者多个语言版本上测试构建，就需要设置构建矩阵。例如，我们想在多个操作系统、多个 Go 版本下跑测试，可以使用如下 workflow 配置：

```yaml
name: Go Test

on: [push, pull_request]

jobs:

  helloci-build:
    name: Test with go ${{ matrix.go_version }} on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        go_version: [1.15, 1.16]
        os: [ubuntu-latest, macOS-latest]

    steps:

      - name: Set up Go ${{ matrix.go_version }}
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go_version }}
        id: go
```

上面的 workflow 配置，通过strategy.matrix配置了该工作流程运行的环境矩阵（格式为go_version.os）：ubuntu-latest.1.15、ubuntu-latest.1.16、macOS-latest.1.15、macOS-latest.1.16。也就是说，会在 4 台不同配置的服务器上执行该 workflow。

#### 使用 Secrets

在构建过程中，我们可能需要用到ssh或者token等敏感数据，而我们不希望这些数据直接暴露在仓库中，此时就可以使用secrets。

```yaml
name: Go Test
on: [push, pull_request]
jobs:
  helloci-build:
    name: Test with go
    runs-on: [ubuntu-latest]
    environment:
      name: helloci
    steps:
      - name: use secrets
        env:
          super_secret: ${{ secrets.YourSecrets }}
```

#### 使用 Artifact 保存构建产物

在构建过程中，我们可能需要输出一些构建产物，比如日志文件、测试结果等。这些产物可以使用 Github Actions Artifact 来存储。你可以使用action/upload-artifact 和 download-artifact 进行构建参数的相关操作。

这里我以输出 Jest 测试报告为例来演示下如何保存 Artifact 产物。Jest 测试后的测试产物是 coverage：

```yaml
steps:
      - run: npm ci
      - run: npm test

      - name: Collect Test Coverage File
        uses: actions/upload-artifact@v1.0.0
        with:
          name: coverage-output
          path: coverage
```

### GitHub Actions 实战

```yaml
name: Go Test

on: [push, pull_request]

jobs:

  helloci-build:
    name: Test with go ${{ matrix.go_version }} on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    environment:
      name: helloci

    strategy:
      matrix:
        go_version: [1.16]
        os: [ubuntu-latest]

    steps:
		# 1.准备一个 Go 编译环境。
      - name: Set up Go ${{ matrix.go_version }}
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go_version }}
        id: go
        
		# 2.从marmotedu/helloci下载源码。
      - name: Check out code into the Go module directory
        uses: actions/checkout@v2
        
		# 3.添加或删除缺失的依赖包。
      - name: Tidy 
        run: |
          go mod tidy
          
		# 4.编译 Go 源码
      - name: Build
        run: |
          go build -v -o helloci .
          
		# 5.上传构建产物。
      - name: Collect main.go file
        uses: actions/upload-artifact@v1.0.0
        with:
          name: main-output
          path: main.go

		# 6.构建镜像，并将镜像 push 到远程仓库
      - name: Publish to Registry
        uses: elgohr/Publish-Docker-GitHub-Action@master
        with:
          name: ccr.ccs.tencentyun.com/marmotedu/helloci:beta  # docker image 的名字
          username: ${{ secrets.DOCKER_USERNAME}} # 用户名
          password: ${{ secrets.DOCKER_PASSWORD }} # 密码
          registry: ccr.ccs.tencentyun.com # 腾讯云Registry
          dockerfile: Dockerfile # 指定 Dockerfile 的位置
          tag_names: true # 是否将 release 的 tag 作为 docker image 的 tag
```

#### 终极版最简构建镜像

```Dockerfile
# 构建
FROM golang:1.18-alpine as builder
WORKDIR /home/project
ENV GOPROXY=https://goproxy.cn
COPY ./ ./
RUN go mod tidy && \
    go mod download && \
    sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories && \
    apk add tzdata
RUN CGO_ENABLED=0 go build -ldflags "-s -w" -o admin

# 打包
FROM alpine as runner
COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
COPY --from=builder /home/project/admin /home/project/
WORKDIR /home/project
ENTRYPOINT ["./admin"]
CMD ["-host", "0.0.0.0", "-port", "8464"]
```

```yaml
name: Build Docker Image

on:
  push:
    branches:
      - master

jobs:
  test-walle-build:

    runs-on: ubuntu-latest

    steps:
      # 1.设置打包 tag。
      - name: Get current date
        id: date
        run: echo "::set-output name=today::$(date +'%Y_%m_%d_%H_%M')"

      # 2.下载源码。
      - name: Check out code into the Go module directory
        uses: actions/checkout@v2

      # 3.构建镜像，并将镜像 push 到远程仓库
      - name: Publish to Registry
        uses: elgohr/Publish-Docker-GitHub-Action@master
        with:
          name: registry.cn-hangzhou.aliyuncs.com/tanwuyang/walle-test   # docker image 的名字
          username: ${{ secrets.DOCKER_USERNAME}} # 用户名
          password: ${{ secrets.DOCKER_PASSWORD }} # 密码
          registry: registry.cn-hangzhou.aliyuncs.com # 腾讯云Registry
          dockerfile: Dockerfile # 指定 Dockerfile 的位置
          tags: "latest,${{ steps.date.outputs.today }}"


```

