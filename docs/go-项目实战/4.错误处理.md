### 内置错误

由于Go 语言的内置 error 过于简单，无法打印堆栈，故使用网上的开源的 error 包

```
https://github.com/pkg/errors
```

该包可以使 error 包含堆栈信息，且对 error 进行包装

### 使用第三方包

#### 对于第三方包丢出的错误

1. 不附加自定义错误信息，只附加堆栈信息，使用 `errors.WithStack(err)`

```go
func withStack() error {
	_, err := os.Create("foo/bar")
	return errors.WithStack(err)
}
// 测试
func Test_withStack(t *testing.T) {
	log.Printf("%+v", withStack())
}
```

输出

```bash
2022/05/12 09:56:27 open foo/bar: The system cannot find the path specified.
golog/cmd.withStack
	E:/www-go/golog/cmd/os.go:20
golog/cmd.Test_withStack
	E:/www-go/golog/cmd/os_test.go:17
testing.tRunner
	D:/Go/src/testing/testing.go:1439
runtime.goexit
	D:/Go/src/runtime/asm_amd64.s:1571
```

2. 附加自定义错误信息，且附加堆栈信息，使用 `errors.Wrap(err, "自定义 message warp")`

```go
func warp() error {
	_, err := os.Create("foo/bar")
	return errors.Wrap(err, "自定义 message warp")
}
// 测试
func Test_warp(t *testing.T) {
	log.Printf("%+v", warp())
}
```

输出

```bash
2022/05/12 09:57:23 open foo/bar: The system cannot find the path specified.
自定义 message warp
golog/cmd.warp
	E:/www-go/golog/cmd/os.go:10
golog/cmd.Test_warp
	E:/www-go/golog/cmd/os_test.go:9
testing.tRunner
	D:/Go/src/testing/testing.go:1439
runtime.goexit
	D:/Go/src/runtime/asm_amd64.s:1571
```

3. 只附加自定义错误信息，不附加堆栈信息，使用 `errors.WithMessage(err, "自定义 message withMessage")`

```go
func withMessage() error {
	_, err := os.Create("foo/bar")
	return errors.WithMessage(err, "自定义 message withMessage")
}
// 测试
func Test_withMessage(t *testing.T) {
	log.Printf("%+v", withMessage())
}
```

输出

```bash
2022/05/12 10:00:16 open foo/bar: The system cannot find the path specified.
自定义 message withMessage
```

#### 业务错误

普通情况

```go
import (
	"github.com/pkg/errors"
)

func foo() error {
	return bar()
}

func bar() error {
	return internalErr()
}

func internalErr() error {
	return errors.New("internal error")
}
```

测试

```go
func Test_Err3(t *testing.T) {
	log.Printf("%+v", foo())
}
```

打印

```bash
# output
2022/05/12 09:36:58 internal error
golog/cmd.internalErr
	E:/www-go/golog/cmd/main.go:16
golog/cmd.bar
	E:/www-go/golog/cmd/main.go:12
golog/cmd.foo
	E:/www-go/golog/cmd/main.go:8
golog/cmd.Test_Err3
	E:/www-go/golog/cmd/main_test.go:17
testing.tRunner
	D:/Go/src/testing/testing.go:1439
runtime.goexit
	D:/Go/src/runtime/asm_amd64.s:1571

```

### 最佳实践

#### 打印错误

支持以下几种格式

|          格式          |            说明             |
| :--------------------: | :-------------------------: |
| log.Printf("%v", err)  |       输出原始message       |
| log.Printf("%+v", err) | 打印堆栈，并输出原始message |
| log.Printf("%s", err)  |       输出原始message       |
| log.Printf("%q", err)  |       输出原始message       |

#### 记录错误

##### 在顶层处理错误

将错误抛出至控制层，由控制层进行处理

```go

import (
	"errors"
	"log"

	myerr "github.com/pkg/errors"
)

func controller() string {
	err := service()
	if err != nil {
		log.Printf("%+v\n", err)
		return "失败"
	}
	return "成功"
}

func service() error {
	err := model()
	return myerr.WithMessage(err, "调用 model 错误")
}

func model() error {
	err := queryDatabase()
	return myerr.WithMessage(err, "数据不存在")
}

func queryDatabase() error {
	err := errors.New("data not found")
	return myerr.WithStack(err)
}
```

##### 在底层处理错误

将错误的信息直接返回，无需对错误再进行封装

```go
func controller2() string {
	err := service2()
	if err != nil {
		return "失败"
	}
	return "成功"
}

func service2() error {
	return model2()
}

func model2() error {
	return queryDatabase2()
}

func queryDatabase2() error {
	err := errors.New("data not found")
	err = myerr.WithStack(err)
	log.Printf("%+v", err)
	return err
}
```

### 其他操作

#### Is(err, target error) bool

判断 err 中是否含有 target (完全相等)

#### As(err error, target interface{}) bool

判断 err 中是否含有 target 类型的 error （类型断言）

#### Unwrap() error

返回上一层的error

#### Cause() error

返回最初始的error
