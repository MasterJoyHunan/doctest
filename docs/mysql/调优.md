### 线程的优化

#### master thread: 核心线程负责

- 将缓冲池的数据异步刷新到磁盘
- 保证数据的一致性
- 脏页的刷新
- 合并插入缓冲
- undo 页的回收

#### IO thread

Innodb 使用 Async IO 处理写 IO 请求, IO thread 主要工作是负责处理这些 IO 的回调

- read thread 默认有4个
- write thread 默认有4个
- insert buffer thread 默认1个
- log thread 默认1个

可以使用 `show variables like 'innodb_%_io_threads'` 查看

```
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| innodb_read_io_threads  | 4     |
| innodb_write_io_threads | 4     |
+-------------------------+-------+
```

通过命令 `show engine innodb status` 查看当前

```
$ show engine innodb status;
--------
FILE I/O
--------
I/O thread 0 state: waiting for completed aio requests (insert buffer thread)
I/O thread 1 state: waiting for completed aio requests (log thread)
I/O thread 2 state: waiting for completed aio requests (read thread)
I/O thread 3 state: waiting for completed aio requests (read thread)
I/O thread 4 state: waiting for completed aio requests (read thread)
I/O thread 5 state: waiting for completed aio requests (read thread)
I/O thread 6 state: waiting for completed aio requests (write thread)
I/O thread 7 state: waiting for completed aio requests (write thread)
I/O thread 8 state: waiting for completed aio requests (write thread)
I/O thread 9 state: waiting for completed aio requests (write thread)
Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,
 ibuf aio reads:, log i/o's:, sync i/o's:
Pending flushes (fsync) log: 0; buffer pool: 0
274 OS file reads, 3456 OS file writes, 1434 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s
```

#### purge thread 

用于回收已经使用并分配的 undo 也,可以 `mysqld` 下设置多个 purge thread, 这样可以加快 undo 页的回收

```
[mysqld]
innodb_purge_threads=4
```

查看当前系统有几个 purge thread 线程使用 `show variables like 'innodb%threads'`

```
+-------------------------+-------+
| Variable_name           | Value |
+-------------------------+-------+
| innodb_purge_threads    | 4     |
| innodb_read_io_threads  | 4     |
| innodb_write_io_threads | 4     |
+-------------------------+-------+
```

#### page cleaner thread 

用于脏页刷新

### 内存优化

#### 缓冲池

数据库是基于硬盘操作,读写速度是很慢的,使用缓冲池能有效的加快对数据的读写操作

缓冲池中缓存的数据页类型有

- 索引页
- 数据页
- 插入缓冲
- 自适应哈希索引
- 锁信息
- 数据字典信息

默认一个数据库只有一个缓冲池,可以通过 `innodb_buffer_pool_instances` 设置多个缓冲池

```shell
$ show engine innodb status;
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 137428992
Dictionary memory allocated 262517
Buffer pool size   8191 # pool 缓存有多少个页 1页=16kb
Free buffers       7186 # free 列表中的数量
Database pages     996  # lru 列表中的数据
Old database pages 347
Modified db pages  0    # 显示脏页数量
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 241, created 755, written 2193
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 996, unzip_LRU len: 0 # unzip_lru 对普通 lru 进行压缩
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
```

还可以通过架构表查看缓冲池信息

```sql
SELECT * FROM `INNODB_BUFFER_POOL_STATS`
POOL_ID
POOL_SIZE
FREE_BUFFERS
DATABASE_PAGES
OLD_DATABASE_PAGES
MODIFIED_DATABASE_PAGES
PENDING_DECOMPRESS
PENDING_READS
PENDING_FLUSH_LRU
PENDING_FLUSH_LIST
PAGES_MADE_YOUNG -- make yong page 
PAGES_NOT_MADE_YOUNG
PAGES_MADE_YOUNG_RATE
PAGES_MADE_NOT_YOUNG_RATE
NUMBER_PAGES_READ
NUMBER_PAGES_CREATED
NUMBER_PAGES_WRITTEN
PAGES_READ_RATE
PAGES_CREATE_RATE
PAGES_WRITTEN_RATE
NUMBER_PAGES_GET
HIT_RATE -- 缓存命中率 越高越好
YOUNG_MAKE_PER_THOUSAND_GETS
NOT_YOUNG_MAKE_PER_THOUSAND_GETS
NUMBER_PAGES_READ_AHEAD
NUMBER_READ_AHEAD_EVICTED
READ_AHEAD_RATE
READ_AHEAD_EVICTED_RATE
LRU_IO_TOTAL
LRU_IO_CURRENT
UNCOMPRESS_TOTAL
UNCOMPRESS_CURRENT
```

###### 缓冲池对读的优化

数据库进行**读取页**的操作,首先判断该页是否在缓冲池中,如果不在,会将磁盘中的页读取到缓冲池中,该过程称为 `FIX`
第二次读取相同的页,发现该页如果在缓冲池中,则称为缓冲命中

###### 缓冲池对写的优化

修改数据首先修改在缓冲池的页,然后再以一定频率刷新到磁盘上,这种机制称为 `checkpoint`

综上所述,缓冲池的大小直接影响数据库的整体性能

查看缓冲池大小的命令 `show variables like 'innodb_buffer_pool_size'`

```
+-------------------------+-----------+
| Variable_name           | Value     |
+-------------------------+-----------+
| innodb_buffer_pool_size | 134217728 | 134217728 / 1024 / 1024 / 1024 = 125MB
+-------------------------+-----------+
```

###### 缓冲池过期算法 LRU

不同于一般的 LRU 算法
新读取的页`默认`放在LRU列表的 63% 的地方,上面63%称为 new 列表(活跃数据), 下面的 27% 称为 old 列表(将被淘汰的数据)
这样做的好处是如果某些sql 进行了大量数据的查找或全表扫描的话,不至于把热点数据全部淘汰

- 设置 `innodb_old_blocks_time`,设置新读取页在多少毫秒之后才能加入到 new 列表,从而尽可能保证热点数据不被刷出
- 设置 `innodb_old_blocks_pct`, 设置新读取页插入到什么位置(1%-99%),设置的越小可保留的热点数据越多 

通过架构表 `innodb_buffer_page_lru` 查询 `lru` 详情

```sql
select * from innodb_buffer_page_lru
POOL_ID
LRU_POSITION
SPACE
PAGE_NUMBER -- 
PAGE_TYPE
FLUSH_TYPE
FIX_COUNT
IS_HASHED
NEWEST_MODIFICATION
OLDEST_MODIFICATION -- 大于 0 的就是脏页
ACCESS_TIME
TABLE_NAME -- 表名
INDEX_NAME
NUMBER_RECORDS
DATA_SIZE
COMPRESSED_SIZE
COMPRESSED
IO_FIX
IS_OLD
FREE_PAGE_CLOCK

```

#### 重做日志缓冲 redo log buffer

innodb 首先会将重做日志放入缓冲区,然后以一定的频率刷新到重做日志文件

- master thread 每秒将重做日志缓冲刷新到重做日志文件
- 每个事务提交会将重做日志刷新到重做日志文件
- 重做日志缓冲区小于 1/2 时,将重做日志缓冲刷新到重做日志文件

重做日志由 `innodb_log_buffer_size` 参数控制,一般为 16M 大小,绝大多数情况下是够用了的
```
show variables like 'innodb_log_buffer_size';
+------------------------+----------+
| Variable_name          | Value    |
+------------------------+----------+
| innodb_log_buffer_size | 16777216 | 16777216 / 1024 / 1024 = 16MB
+------------------------+----------+
```

#### 额外的内存池

对数据结构本身的内存分配,需要从额外的内存池进行,如果额外的内存池不够时,会从缓冲池中进行申请
该配置项为 `innodb_additional_mem_pool_size`

### checkpoint 检查点技术

**checkpoint 所做的事就是将缓冲池中的脏页刷新到磁盘上**

如果每次cud操作都将新版本刷新到磁盘,那么这个开销太大了,数据库的性能就会变的很差,如果将缓冲池的页刷新到磁盘的过程中发送的宕机,那么数据就不能恢复

为了避免数据丢失的问题,大部分数据库都采用了 write ahead log 策略, 当事务提交时,先写重做日志,再修改页.
如果发送宕机而导致数据丢失,可以通过重做日志来完成数据的恢复

检查点的技术解决以下几个问题

- 缩短数据库的恢复时间
    - 当数据库发生宕机时,数据库不需要重做所有的日志,只需要对 checkpoint 之后的重做日志进行恢复,这样就可能大大的缩短恢复时间
    - 因为 checkpoint 之前的数据已经刷新到了磁盘
- 缓冲池不够用时,将脏页刷新到磁盘
    - 缓冲池不够用时,会使用 lru 算法淘汰最少使用的页,如果发现该页为脏页,则立即执行 checkpoint ,将脏页刷新到磁盘
- 重做日志缓冲不够用时,刷新张脏页
    - 重做日志缓冲需要复用,所以会进行回收,当回收时会强行触发 checkpoint 

#### 查看 checkpoint

```
$ show engine innodb status;
---
LOG
---
Log sequence number 10501749
Log flushed up to   10501749
Pages flushed up to 10501749
Last checkpoint at  10501740
0 pending log flushes, 0 pending chkp writes
967 log i/o's done, 0.00 log i/o's/second
```

