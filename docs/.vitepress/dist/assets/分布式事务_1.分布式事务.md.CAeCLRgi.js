import{_ as t,c as e,a2 as i,o}from"./chunks/framework.DPuwY6B9.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"分布式事务/1.分布式事务.md","filePath":"分布式事务/1.分布式事务.md","lastUpdated":1729815932000}'),l={name:"分布式事务/1.分布式事务.md"};function r(s,a,n,c,p,d){return o(),e("div",null,a[0]||(a[0]=[i('<h3 id="分布式事务" tabindex="-1">分布式事务 <a class="header-anchor" href="#分布式事务" aria-label="Permalink to &quot;分布式事务&quot;">​</a></h3><p>在微服务的环境下，多个微服务需要对业务（可能不同的数据库之间）进行事务操作时，需要使用分布式事务保证数据的一致性</p><p>如转账业务，一个微服务负责转出，一个微服务负责转入，当其中转入服务失败，导致转出的金额减少，转入的金额没有增加，这是在现实中决不允许发生的，此时我们将需要一个事务的协调者（管理者），对子事务进行提交、回滚、补偿、等一系列操作</p><h3 id="事务的acid" tabindex="-1">事务的ACID <a class="header-anchor" href="#事务的acid" aria-label="Permalink to &quot;事务的ACID&quot;">​</a></h3><ul><li>Atomicity（原子性）：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。完整性包括外键约束、应用定义等约束不会被破坏。</li><li>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li><li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>主流的数据库 mysql 、postgresql 都支持 ACID 事务，内部使用 MVCC (多版本并发控制）技术，实现高性能、高并发的本地事务</p><h3 id="最终一致性" tabindex="-1">最终一致性 <a class="header-anchor" href="#最终一致性" aria-label="Permalink to &quot;最终一致性&quot;">​</a></h3><p>目前在跨库、跨服务的分布式实际应用中，尚未看到有强一致性的方案。由于是分布式系统。无法保证两个 commit 同时结束，只要两个 commit 有时间差，在两个 commit 之前执行查询操作，导致的结果就是数据和理想中的不一致。</p><p>但是在两个 commit 结束之后，整体事务完成后，再进行查询，结果将是最终一致。</p><p>总结：在分布式事务进行中，一致性无法得到很好的保证，在分布式事务完成后，一致性是没有问题的</p>',10)]))}const _=t(l,[["render",r]]);export{h as __pageData,_ as default};
