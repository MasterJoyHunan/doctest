import{_ as l,c as t,a2 as i,o as e}from"./chunks/framework.DPuwY6B9.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"分布式事务/2.SAGA.md","filePath":"分布式事务/2.SAGA.md","lastUpdated":1729761429000}'),o={name:"分布式事务/2.SAGA.md"};function r(p,a,s,n,c,d){return e(),t("div",null,a[0]||(a[0]=[i('<h3 id="saga-事务模式" tabindex="-1">SAGA 事务模式 <a class="header-anchor" href="#saga-事务模式" aria-label="Permalink to &quot;SAGA 事务模式&quot;">​</a></h3><p>核心思想：将长事务拆分为多个短事务，由事务管理器负责协调。如果每个短事务都成功，则全局事务就成功，如果某个步骤失败，则根据相反顺序调用一次补偿操作</p><p>优点：简单易用，能满足绝大部分业务需求</p><h3 id="时序图" tabindex="-1">时序图 <a class="header-anchor" href="#时序图" aria-label="Permalink to &quot;时序图&quot;">​</a></h3><h4 id="正常时序图" tabindex="-1">正常时序图 <a class="header-anchor" href="#正常时序图" aria-label="Permalink to &quot;正常时序图&quot;">​</a></h4><p><img src="http://tc.masterjoy.top/typory/image-20240710111631462.png" alt="image-20240710111631462"></p><ol><li>主程序将编排的事务，包括正向操作、反向补偿定义好，提交给事务管理器</li><li>事务管理器根据提交的事务调用服务1的正向操作（成功）</li><li>事务管理器根据提交的事务调用服务2的正向操作（成功）</li><li>成功执行了一次分布式事务</li></ol><h4 id="失败时序图" tabindex="-1">失败时序图 <a class="header-anchor" href="#失败时序图" aria-label="Permalink to &quot;失败时序图&quot;">​</a></h4><p><img src="http://tc.masterjoy.top/typory/image-20240710112344350.png" alt="image-20240710112344350"></p><ol><li>主程序将编排的事务，包括正向操作、反向补偿定义好，提交给事务管理器</li><li>事务管理器根据提交的事务调用服务1的正向操作（成功）</li><li>事务管理器根据提交的事务调用服务2的正向操作（失败）</li><li>事务管理器根据提交的事务调用服务2的补偿操作</li><li>事务管理器根据提交的事务调用服务1的补偿操作</li><li>分布式事务失败</li></ol><p>理论上没问题，但是如何处理补偿机制的问题？</p><ol><li>正常操作是否执行（成功、失败、正在执行）？</li><li>补偿操作如果失败了？</li><li>重复执行补偿机制（幂等问题）？</li></ol><p>解决上面的问题就需要到子事务屏障技术</p>',13)]))}const u=l(o,[["render",r]]);export{m as __pageData,u as default};
