### 工作队列 

多个消费者同时消费同一个队列，但是一条消息只能被消费一次。默认情况下，采用轮训分发，每个消费者轮流消费一条数据。

#### 使用不公平分发 QOS

能者多劳模式，如果特定的机器处理速度较快，当处理完毕了一条消息，会里面处理下一条消息，这种方式就发挥机器的最大价值。不公平分发在消费者端设置

```go
connection, err := amqp.Dial("amqp://test1:test@127.0.0.1:5672/test")
if err != nil {
    panic(err)
}

defer connection.Close()

channel, err := connection.Channel()

if err != nil {
    panic(err)
}

defer channel.Close()
err = channel.Qos(1, 0, false)
```

参数说明

| 参数          | 描述                            | 备注                                                         |
| ------------- | ------------------------------- | ------------------------------------------------------------ |
| prefetchCount | 预取值                          | 0：不设置，将被轮训分发。<br />大于0：每次取 prefetchCount 条数据进行消费，消费完毕之后就会继续在队列里面拉取消息 |
| prefetchSize  | 0                               |                                                              |
| global        | 应用于 channel 还是当前所有连接 | false：channel 上所有消费者共享（默认值） <br />true： 连接上的所有消费者共享 |

### 死信队列

由于队列中的消息无法被消费，这样的消息没有后续的处理，自然变成的死信队列，如：处理消息出现异常，将消息发送至死信队列中，防止消息丢失

死信来源

1. 消息TTL 过期 -- 消费死信队列，可以作为延时队列使用
2. 队列达到最大长度，队列满了
3. 消息被拒绝（消费者返回 reject、nack，并且 requeue = false）

在声明队列的时候，设置 argument 的 map，将普通消息消费失败至死信交换机

| key                       | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| x-message-ttl             | 队列的里消息的过期时间，单位毫秒，也可以在生产者发送消息的时候设置消息过期时间 |
| x-dead-letter-exchange    | 设置死信交换机                                               |
| x-dead-letter-routing-key | 设置死信 routing key                                         |
| x-max-length              | 设置队列长度                                                 |

死信队列代码和正常的消费者一致

```go
... // 建立连接代码略
err = channel.ExchangeDeclare("dead-exchange", "direct", true, false, false, false, nil) 
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("dead-queue", false, false, false, false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("dead-queue", "default", "dead-exchange", false, nil)
if err != nil {
    panic(err)
}

consume, err := channel.Consume("dead-queue", "", false, false, false, false, nil)

for x := range consume {
    log.Println("dead-queue 接收到消息" + string(x.Body))
    err = x.Ack(false)
    if err != nil {
        panic(err)
    }
}
```

#### 超时产生死信

超时生产者代码

```go
... // 建立连接代码略
for i := 0; i < 10; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "normal-exchange",
        "default",
        false,
        false,
        amqp.Publishing{
            Body:         []byte("normal => " + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
            Expiration:   "10000", // 10s (单位毫秒)
        },
    )
    if err != nil {
        panic(err)
    }
}
```

超时消费者代码

```go
... // 建立连接代码略
err = channel.ExchangeDeclare("normal-exchange", "direct", true, false, false, false, nil)
if err != nil {
    panic(err)
}

// 关键点，在声明队列时，设置死信队列
_, err = channel.QueueDeclare("normal-queue", false, false, false, false, amqp.Table{
    "x-dead-letter-exchange":    "dead-exchange", // 死信队列 交换机
    "x-dead-letter-routing-key": "default",       // 死信队列 routing key
})
if err != nil {
    panic(err)
}

err = channel.QueueBind("normal-queue", "default", "normal-exchange", false, nil)
if err != nil {
    panic(err)
}

// 使用 select {} 阻塞代码，不消费 normal-queue 的消息
select {}
```

#### 队列达到最大长度产生死信

生产者

```go
... // 建立连接代码略
for i := 0; i < 11; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "normal-exchange1", 
        "default",
        false,
        false,
        amqp.Publishing{
            Body:         []byte("normal => " + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        panic(err)
    }
}
```

消费者

```go
... // 建立连接代码略
err = channel.ExchangeDeclare("normal-exchange1", "direct", true, false, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("normal-queue1", false, false, false, false, amqp.Table{
    "x-dead-letter-exchange":    "dead-exchange",
    "x-dead-letter-routing-key": "default",
    "x-max-length":              5, // 队列最大长度设置为 5,
})
if err != nil {
    panic(err)
}

err = channel.QueueBind("normal-queue1", "default", "normal-exchange1", false, nil)
if err != nil {
    panic(err)
}

select {}
```

#### 消息被拒绝产生死信

生产者

```go
... // 建立连接代码略
for i := 0; i < 11; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "normal-exchange2",
        "default",
        false,
        false,
        amqp.Publishing{
            Body:         []byte("normal => " + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        panic(err)
    }
}
```

消费者

```go
... // 建立连接代码略
err = channel.ExchangeDeclare("normal-exchange2", "direct", true, false, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("normal-queue2", false, false, false, false, amqp.Table{
    "x-dead-letter-exchange":    "dead-exchange",
    "x-dead-letter-routing-key": "default",
})
if err != nil {
    panic(err)
}

err = channel.QueueBind("normal-queue2", "default", "normal-exchange2", false, nil)
if err != nil {
    panic(err)
}

consume, err := channel.Consume("normal-queue2", "", false, false, false, false, nil)

for x := range consume {
    log.Println("normal-queue2 接收到消息" + string(x.Body))
    err = x.Nack(false, false) // 也可以使用 x.Reject(false)
    if err != nil {
        panic(err)
    }
}
```

#### 延迟队列

相当于生产者发送 ttl 消息给消费者，再将消费者设置不消费消息，到了一定的时间后，消息过期，消费者自动将消息转发至死信队列

理论上可行，但是实际操作会有些反直觉的情况，如：生产者发送消息的时候设置了超时时间，当第一个入队的消息超时时间是20秒，第二个入队的消息超时时间是2秒。当时间过去2秒后，rabbitmq 不会将超时 2 秒的那条消息先放入到死信队列，而是会判断第一个入队的消息是否超时，等待20秒超时后，会将第一个消息放入死信队列，然后再操作第二个入队的消息，直接会导致第二个入队的消息超过了20秒才能被放入死信队列

可以安装延时队列插件弥补这种情况

* 社区插件地址：https://www.rabbitmq.com/community-plugins.html
* 延迟队列插件地址：https://github.com/rabbitmq/rabbitmq-delayed-message-exchange

1. 在 release 中下载 `rabbitmq_delayed_message_exchange-3.8.17.8f537ac.ez` 
2. 将 `.ez` 文件复制到 `/opt/rabbitmq/plugins` 目录下
3. `rabbitmq-plugins enable rabbitmq_delayed_message_exchange` 启用插件
4. 声明交换机的时候，设置交换机的类型为 `x-delayed-message`
5. 生产者将消息发送至交换机类型为 `x-delayed-message` 的交换机，并且设置 `x-delay` 值为延时多少秒

>  注意，和原先的消息在队列超时不同，插件是设置在交换机上的消息超时，由于不需要在队列中做超时，那就不需要死信队列了

生产者代码

```go
... // 建立连接代码略
delays := []int{
    20000,
    2000,
    1000,
    5000,
    4000,
    8000,
}
for i, delay := range delays {
    err = channel.PublishWithContext(
        context.Background(),
        "delays-exchange", // 交换机
        "default",
        false,
        false,
        amqp.Publishing{
            Body:         []byte(strconv.Itoa(delay) + "_" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
            Headers: amqp.Table{
                "x-delay": delay, // 延迟参数，单位毫秒
            },
        },
    )
    if err != nil {
        panic(err)
    }
}
```

消费者代码， 重点设置交换机类型为 `x-delayed-message`， 附加参数 `x-delayed-type = direct`，其他地方和普通交换机绑定队列是一致的

```go
... // 建立连接代码略
// 重点设置交换机这里
err = channel.ExchangeDeclare("delayed-exchange", "x-delayed-message", true, false, false, false, amqp.Table{
    "x-delayed-type": "direct",
})
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("delayed-queue", false, false, false, false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("delayed-queue", "default", "delayed-exchange", false, nil)
if err != nil {
    panic(err)
}

consume, err := channel.Consume("delayed-queue", "", false, false, false, false, nil)
for x := range consume {
    log.Println("delayed-queue 接收到延迟消息" + string(x.Body))
    err = x.Ack(false)
    if err != nil {
        panic(err)
    }
}
```

