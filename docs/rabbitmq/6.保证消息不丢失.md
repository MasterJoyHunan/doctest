### 发布确认高级

在生产环境中，如果 rabbitmq 宕机了，而我们的生产者没有感知到，继续发送消息给交换机。这种情况下，交换机是无法保存生产者发送的消息。为了解决这种情况。先使用缓存将生产者发送的消息缓存起来，等待 rabbitmq 服务恢复，然后通过定时任务在逐步发送消息

在 spring-boot 中可以设置 `publish-confirm-type = correlated` 并且实现 RabbitTemplate.ConfirmCallback 接口。在消息发送至交换机失败的时候，会回调 ConfirmCallback  接口，但是在 go 语言中没有这个功能，只能在发送消息的时候判断 err 是否为 nil， 再根据 err 来处理后续逻辑

```go
err = channel.Confirm(false) // 确认
if err != nil {
    panic(err)
}

publishNotify := make(chan amqp.Confirmation)
channel.NotifyPublish(publishNotify)
go func() {
    for notify := range publishNotify {
        if notify.Ack {
            log.Printf("%d 投递成功", notify.DeliveryTag)
        } else {
            // 从来没有收到过为 false 的消息
            log.Printf("%d 投递失败", notify.DeliveryTag)
        }
    }
    log.Println("publishNotify 结束")
}()

for i := 0; i < 100; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "confirm-exchange",
        "default",
        true,
        false,
        amqp.Publishing{
            Body:         []byte("hello_" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )

    if err != nil {
        log.Printf("%+v", err)
        // TODO 消息发送失败执行操作
    }
}
```

### 消息回退

当交换机通过 routing key 找不到对应的 queue 时的回调。需要在发布消息的时候设置 mandatory = true，否则默认丢弃该消息

```go
returnNotify := make(chan amqp.Return)
channel.NotifyReturn(returnNotify) // 设置回调 channel

go func() {
    for r := range returnNotify { // 监听回调 channel 
        log.Printf("%s returnNotify", string(r.Body))
    }
}()

for i := 0; i < 100; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "confirm-exchange", // 正常的交换机
        "default1",         // 未定义的 routing key
        true,               // 需要将 mandatory 设置为 true
        false,
        amqp.Publishing{
            Body:         []byte("hello_" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        log.Printf("%+v", err)
    }
}
```

### 备份交换机

正常交换机接收到消息时，但是没有找到对应的 routing key 时，会自动将消息转发到备份交换机上，而不是让消息回退的一种机制

> 当同时设置了消息回退，和备份交换机时，MQ会优先使用备份交换机

![image-20240122141022051](http://tc.masterjoy.top/typory/image-20240122141022051.png)

生产者代码

```go
for i := 0; i < 100; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "confirm-exchange2", // 交换机是正常的
        "default2",          // 对应的路由是不存在的
        true,                // 如果同时配置了 mandatory = true, 和备份消息，那么备份消息优先
        false,
        amqp.Publishing{
            Body:         []byte("hello_" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )

    if err != nil {
        log.Printf("%+v", err)
        // TODO 消息发送失败执行操作
    }
}
```

正常消费者代码

```go
err = channel.ExchangeDeclare("confirm-exchange2", "direct", true, false, false, false, amqp.Table{
    "alternate-exchange": "backup-exchange", // 重点 -- 设置备份交换机
})
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("confirm-queue2", true, false, false, false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("confirm-queue2", "default", "confirm-exchange2", false, nil)
if err != nil {
    panic(err)
}

consume, err := channel.Consume("confirm-queue2", "", false, false, false, false, nil)

for x := range consume {
    log.Println("confirm-queue2 接收到消息" + string(x.Body))
    err = x.Ack(false)
    if err != nil {
        panic(err)
    }
}
```

备份消费者代码

```go
err = channel.ExchangeDeclare("backup-exchange", amqp.ExchangeFanout, true, false, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("backup-queue", true, false, false, false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("backup-queue", "", "backup-exchange", false, nil)
if err != nil {
    panic(err)
}

consume, err := channel.Consume("backup-queue", "", false, false, false, false, nil)

for x := range consume {
    log.Println("backup-queue 接收到消息" + string(x.Body))
    err = x.Ack(false)
    if err != nil {
        panic(err)
    }
}
```

### 优先级队列

优先级队列能将优先级较高的消息优先消费。

在队列中，在声明队列时设置参数  `x-max-priority = 0~255 ` ，然后再发送消息的时候，设置消息优先级，优先级不能超过队列参数 `x-max-priority` 的值

生产者代码

```go
for i := 0; i < 100; i++ {
    var priority uint8 // 优先级定义， 只允许使用 0-9 的优先级
    if i%5 == 0 {
        priority = 5 
    }
    err = channel.PublishWithContext(
        context.Background(),
        "pri-exchange",
        "default",
        false,
        false,
        amqp.Publishing{
            Body:         []byte("hello_" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
            Priority:     priority, // 发送消息使用的优先级
        },
    )

    if err != nil {
        log.Printf("%+v", err)
        // TODO 消息发送失败执行操作
    }
}
```

消费者代码

```go
err = channel.ExchangeDeclare("pri-exchange", "direct", true, false, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("pri-queue", true, false, false, false, amqp.Table{
    "x-max-priority": 10, // 重点，在声明队列中设置队列能使用的优先级
})
if err != nil {
    panic(err)
}

err = channel.QueueBind("pri-queue", "default", "pri-exchange", false, nil)
if err != nil {
    panic(err)
}

consume, err := channel.Consume("pri-queue", "", false, false, false, false, nil)

for x := range consume {
    log.Println("pri-queue 接收到消息" + string(x.Body))
    err = x.Ack(false)
    if err != nil {
        panic(err)
    }
}
```

### 惰性队列

一般情况下，默认使用正常队列，正常队列内的消息都会存储在内存中，但是，如果消费者宕机情况下，队列里面的消息积压过多，将会浪费内存资源，使用惰性队列将会把内存中的消息存储在硬盘中，以节省内存资源

在声明队列中，设置参数 `x-queue-mode=lazy`

### rabbitmq 集群与镜像队列

多台 rabbitmq 组成一个集群，用于保证MQ服务的高可用，虽然是集群，但是该集群对消费者生产消息，和消费者消费消息没有提升其性能，自是用于当某台服务器宕机后，rabbitmq 依然可以正常使用。

当某台服务器宕机后，保存在该服务上的队列中的消息会丢失。如何解决该问题，就是使用镜像队列策略。某台服务器的队列会被镜像到另一台服务器中。

设置镜像队列策略的参数，在polic 中设置3个参数

![image-20240122152257638](http://tc.masterjoy.top/typory/image-20240122152257638.png)

### 



