### 消费者

用于消费队列里面的消息

```go
consume, err := channel.Consume(queue.Name, "", true, false, false, false, nil)
for x := range consume {
    log.Println("接收到消息" + string(x.Body))
}
```

参数说明

| 参数      | 描述             | 备注                                                         |
| --------- | ---------------- | ------------------------------------------------------------ |
| queue     | 队列名           |                                                              |
| consumer  | 消费者名         | 如果为空则自动创建一个全局唯一的名字                         |
| autoAck   | 自动确认消息     | 防止数据丢失，推荐使用 true                                  |
| exclusive | 是否排他         | true：服务器保证只有唯一的消费者<br />false：可以被其他消费者消费 |
| noLocal   | -                | rabbitmq 不支持 noLocal                                      |
| noWait    | 是否等待服务确认 | true：无需等待服务器确认，false：无需等待服务器确认          |
| args      | 其他参数         |                                                              |

### 保证消息被消费

1）需要设置不自动确认消息 `autoAck = false`

2）接受到消息，处理完成之后再手动返回 `ack`

```go
consume, err := channel.Consume(queue.Name, "", false, false, false, false, nil)
for x := range consume {
    log.Println("接收到消息" + string(x.Body))
    err = x.Ack(false) // 关键点，手动返回 Ack
    if err != nil {
        panic(err)
    }
    log.Println("接收完毕")
}
```

ack 批量应答参数 `multiple` 说明如下

| multiple 值设置 | 描述                                                  |
| --------------- | ----------------------------------------------------- |
| true            | 会将 channel 里面所有的消息应答                       |
| false           | 只会应答当前接收到的消息 （无特殊情况推荐使用 false） |

如果消费者没有发送 ack 应答，**消息将会被重新入队**，保证消息不会被丢失
