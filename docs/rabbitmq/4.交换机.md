### 交换机

生产者产生的消息不直接发送至队列，而是先发送至交换机，再通过交换机发送至队列

交换机接受生产者产生消息，必须知道如何正确的处理收到的消息，决定将该消息发到特定的队列中还是放到多个队列中，还是丢弃该消息

交换机的类型

* direct -- 直接
* topic -- 主题
* headers -- 标题 （不常用）
* fanout -- 扇出

当发送消息时不指定交换机，则会使用默认交换机，key 参数就指的是队列的名字，如果指定了交换机的名字，则 key 值就需要填写交换机和路由绑定的 key

### 声明交换机

```go
err = channel.ExchangeDeclare("test-fanout", "fanout", true, false, false, false, nil)
```

参数说明

| 参数       | 描述                 | 备注                                                         |
| ---------- | -------------------- | ------------------------------------------------------------ |
| name       | 交换机名             |                                                              |
| kind       | 交换机类型           | direct 、topic 、headers 、fanout、不同类型交换机有不同的功能 |
| durable    | 是否持久化           | 非持久化的和自动删除的队列将会重启后被删除                   |
| autoDelete | 是否自动删除         | 非持久化的和自动删除的队列将会重启后被删除                   |
| internal   | 是否为内部交换机     | true：将不接受消息，用于内部使用，false：正常交换机          |
| noWait     | 声明是否等待服务确认 | true：无需等待服务器确认，false：无需等待服务器确认          |
| args       | 其他参数             |                                                              |

### 扇出模式 （发布订阅模式）

多个消费者消费同样的消息

消费者代码

```go
connection, err := amqp.Dial("amqp://test1:test@127.0.0.1:5672/test")
if err != nil {
    panic(err)
}

defer connection.Close()

channel, err := connection.Channel()

if err != nil {
    panic(err)
}

defer channel.Close()

// 声明交换机的类型为 fanout
err = channel.ExchangeDeclare("test-fanout", "fanout", true, false, false, false, nil)
if err != nil {
    panic(err)
}

// 声明一个队列，队列名为空，系统会自动生成一个全局唯一的队列名
queue, err := channel.QueueDeclare("", false, true, false, false, nil)
if err != nil {
    panic(err)
}

// 将交换机与队列进行绑定，key 为空
err = channel.QueueBind(queue.Name, "", "test-fanout", false, nil)
if err != nil {
    panic(err)
}

// 消费队列里面的消息
consume, err := channel.Consume(queue.Name, "", false, false, false, false, nil)
for x := range consume {
    log.Println("fanout_consume.go 接收到消息" + string(x.Body))
    err = x.Ack(false)
    if err != nil {
        panic(err)
    }
}
```

生产者代码

```go
connection, err := amqp.Dial("amqp://test1:test@127.0.0.1:5672/test")
if err != nil {
    panic(err)
}

defer connection.Close()

channel, err := connection.Channel()

if err != nil {
    panic(err)
}

defer channel.Close()

for i := 0; i < 1000; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "test-fanout", // 交换机名
        "", // key 为空
        false,
        false,
        amqp.Publishing{
            Body:         []byte("hello world" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        panic(err)
    }
}
```

### 直接交换机 direct

生产者发送消息至交换机，只能路由至一个特定的队列

![image-20240118163910599](http://tc.masterjoy.top/typory/image-20240118163910599.png)

生产者

```go
... // 建立连接代码略
for i := 0; i < 1000; i++ {
    key := ""
    switch i % 3 {
        case 0:
        key = "info"
        case 1:
        key = "trace"
        case 2:
        key = "error"
    }

    err = channel.PublishWithContext(
        context.Background(),
        "test-direct",
        key,
        false,
        false,
        amqp.Publishing{
            Body:         []byte(key + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        panic(err)
    }
}
```

消费者

```go
... // 建立连接代码略
err = channel.ExchangeDeclare("test-direct", "direct", true, false, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("queue1", false, true, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("queue2", false, true, false, false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("queue1", "info", "test-direct", false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("queue1", "trace", "test-direct", false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("queue2", "error", "test-direct", false, nil)
if err != nil {
    panic(err)
}

consume1, err := channel.Consume("queue1", "", false, false, false, false, nil)
go func() {
    for x := range consume1 {
        log.Println("queue1 接收到消息" + string(x.Body))
        err = x.Ack(false)
        if err != nil {
            panic(err)
        }
    }
}()

consume2, err := channel.Consume("queue2", "", false, false, false, false, nil)
go func() {
    for x := range consume2 {
        log.Println("queue2 接收到消息" + string(x.Body))
        err = x.Ack(false)
        if err != nil {
            panic(err)
        }
    }
}()
select {}
```

### 主题交换机 topic

最强大、最灵活的交换机，支持通配符 `*` 和 `#` routingkey 定义，多个单词使用英文 `.` 分割，routingkey 不能超过 255 个字节

| 通配符 | 描述               |
| ------ | ------------------ |
| *      | 代表一个单词       |
| #      | 代表零个或多个单词 |

* 如果某个 routingkey 为 # 表示接受所有的消息，类似 fanout 交换机
* 如果 routingkey  没有 *、# ，那就类似 direct 交换机

![image-20240118170723798](http://tc.masterjoy.top/typory/image-20240118170723798.png)

生产者代码

```go
... // 建立连接代码略
keys := []string{
    "foo.a.q",
    "q.bar.z",
    "foo.bar.q",
    "foo.x.baz",
    "x.bar.baz",
    "baz",
}
for i, key := range keys {
    err = channel.PublishWithContext(
        context.Background(),
        "test-topic",
        key,
        false,
        false,
        amqp.Publishing{
            Body:         []byte(key + "_" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        panic(err)
    }
}
```

消费者代码

```go
... // 建立连接代码略
err = channel.ExchangeDeclare("test-topic", "topic", true, false, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("q1", false, true, false, false, nil)
if err != nil {
    panic(err)
}

_, err = channel.QueueDeclare("q2", false, true, false, false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("q1", "foo.*.*", "test-topic", false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("q1", "*.bar.*", "test-topic", false, nil)
if err != nil {
    panic(err)
}

err = channel.QueueBind("q2", "#.baz", "test-topic", false, nil)
if err != nil {
    panic(err)
}

consume1, err := channel.Consume("q1", "", false, false, false, false, nil)
go func() {
    for x := range consume1 {
        log.Println("q1 接收到消息" + string(x.Body))
        err = x.Ack(false)
        if err != nil {
            panic(err)
        }
    }
}()

consume2, err := channel.Consume("q2", "", false, false, false, false, nil)
go func() {
    for x := range consume2 {
        log.Println("q2 接收到消息" + string(x.Body))
        err = x.Ack(false)
        if err != nil {
            panic(err)
        }
    }
}()
select {}
```

