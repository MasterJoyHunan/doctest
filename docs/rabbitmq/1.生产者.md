### 生产者

用于发布消息

```go
err = channel.PublishWithContext(
    context.Background(),
    "",
    "queue",
    false,
    false,
    amqp.Publishing{
        Body:         []byte("hello world" + strconv.Itoa(i)),
        DeliveryMode: amqp.Persistent,
    },
)
```

参数说明

| 参数      | 描述           | 备注                                                         |
| --------- | -------------- | ------------------------------------------------------------ |
| exchange  | 使用哪个交换机 | 不填则使用默认交换机（AMQP default）                         |
| key       | 路由的 key 值  | 当发送消息时不指定交换机，则会使用默认交换机，key 参数就指的是队列的名字<br />如果指定了交换机的名字，则 key 值就需要填写交换机和路由绑定的 routing key |
| mandatory | 强制           | false：当消息无法通过交换器匹配到队列时，会丢弃消息。<br />true：当消息无法通过交换器匹配到队列时，会调用basic.return通知生产者。 |
| immediate | 立刻           | true：当消息到达Queue后，发现队列上无消费者时，通过basic.Return返回给生产者。 <br />false：消息一直缓存在队列中，等待生产者。 |
| msg       | 消息内容       | 可以指定消息是否持久化<br />指定消息的MIME<br />...          |
| args      | 其他参数       |                                                              |

### 保证消息发出去

#### 消息持久化

默认发布消息是不持久化的，当 rabbitmq 意外重启后，队列中的未被消费的消息会丢失。将发送消息设置持久化 `DeliveryMode: amqp.Persistent`

```go
amqp.Publishing{
    Body:         []byte("hello world"),
    DeliveryMode: amqp.Persistent, // 重点
},
```

#### 使用发布确认

发送消息时，等待服务器返回确认收到消息

##### 1）单个确认

优点：消息不会丢失

缺点：发布消息特别的慢

```go
connection, err := amqp.Dial("amqp://test1:test@127.0.0.1:5672/test")
if err != nil {
    panic(err)
}

defer connection.Close()

channel, err := connection.Channel()

if err != nil {
    panic(err)
}

defer channel.Close()

err = channel.Confirm(false) // 开启发布确认模式
if err != nil {
    panic(err)
}

err = channel.PublishWithContext(
    context.Background(),
    "",
    "hello",
    false,
    false,
    amqp.Publishing{
        Body:         []byte("hello world" + strconv.Itoa(i)),
        DeliveryMode: amqp.Persistent,
    },
)
if err != nil {
    panic(err)
}

if ack.Wait() { // 等待发送成功通知
	log.Println("发送成功")
} else {
    log.Println("发送失败")
}
```

##### 2）批量确认

优点：发布消息较快

缺点：不保证消息是否丢失

```go
connection, err := amqp.Dial("amqp://test1:test@127.0.0.1:5672/test")
if err != nil {
    panic(err)
}

defer connection.Close()

channel, err := connection.Channel()

if err != nil {
    panic(err)
}

defer channel.Close()

err = channel.Confirm(false) // 开启发布确认模式
if err != nil {
    panic(err)
}

for i := 0; i < 1000; i++ {
    err = channel.PublishWithContext(
        context.Background(),
        "",
        "hello",
        false,
        false,
        amqp.Publishing{
            Body:         []byte("hello world" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        panic(err)
    }

	// 每发 100 条再确认一次
    if (i+1)%100 == 0 {
    	if ack.Wait() {
    		log.Println("发送成功")
    	} else {
    		log.Println("发送失败")
    	}
    }
}
```

##### 3）异步确认 -- 最优解

优点：发布消息快，又能解决消息丢失的问题

缺点：代码实现较为复杂

```go
connection, err := amqp.Dial("amqp://test1:test@127.0.0.1:5672/test")
if err != nil {
    panic(err)
}

defer connection.Close()

channel, err := connection.Channel()

if err != nil {
    panic(err)
}

defer channel.Close()

err = channel.Confirm(false)
if err != nil {
    panic(err)
}

ack, nack := make(chan uint64), make(chan uint64)
channel.NotifyConfirm(ack, nack)  // 定义两个 go channel 监听发布成功和发布失败的消息 ID

go func() {
    for {
        select {
            case ackId := <-ack:
            log.Printf("ackID = %d \n", ackId)
            case nackId := <-nack:
            log.Printf("nackID = %d \n", nackId)
        }
    }
}()

for i := 0; i < 1000; i++ {
    dc, err = channel.PublishWithDeferredConfirmWithContext(
        context.Background(),
        "",
        "hello",
        false,
        false,
        amqp.Publishing{
            Body:         []byte("hello world" + strconv.Itoa(i)),
            DeliveryMode: amqp.Persistent,
        },
    )
    if err != nil {
        panic(err)
    }
    
    log.Println(dc.DeliveryTag) // 获取到发送的消息 ID, 可以保存消息 ID 到一个 List 中，然后在监听发布成功后移除该消息 ID
}
```

